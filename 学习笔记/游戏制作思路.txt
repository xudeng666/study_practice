编程框架：
	初始化
	while (running)					
	{
		读取操作
		处理数据
		绘制画面
	}
	释放资源
	【注意】主循环推荐用一个bool类型全局变量来控制游戏是否继续。
	
游戏动画一般分分为：
	序列帧动画
	关键帧动画
		骨骼动画
	
关于帧数和效能:
	问题1：
		计算机在执行while主循环时，顷刻间会执行成千上万次，会占据大量CPU时间，对于大多数物理帧率只有60HZ的设备而言非常浪费。
	解决方法：
		用sleep(n); 
			n代指毫秒数，即在主循每次环执行完后，让电脑程序暂停n毫秒再开启下一个循环。
			因为随着游戏体量的不同，以及操作系统对CPU计算资源的分配，n不适合写成一个固定的值。
			所以应该在循环开始和结束时各获取一个时间戳，动态计算该循环这一次一共花费了多长时间。
			例：
			while (running)					
			{
				DWORD stime = GetTickCount();
				读取操作
				处理数据
				绘制画面
				DWORD etime = GetTickCount();
				DWORD dtime = etime - stime;
				if (dtime < 1000 / FPS)			// 这里表示计算机在维持游戏帧率还有余力时，再做sleep节省计算机资源。
				{
					Sleep(1000 / FPS - dtime);
				}
			}
			【注意】sleep是一个阻塞式的行为
	问题2：
		随着游戏体量增大，如何控制游循环在指定FPS类执行？
	解决办法：
		主循环内应该尽量避免阻塞式的行为，或者过于繁重且耗时过长的任务。
		即面对过于繁重且耗时过长的任务，应该分摊到多个循环中执行。
		这也是很多游戏的优化方向。
	
	问题3:
		在移动游戏角色时，点击前进按钮，会先抽动一下再连续前进，且前进有时卡顿。
	问题分析：
		前进按钮点击时，会先触发一次前进消息，然后等一段时间才会触发连续的前进消息，这是抽动一下再移动的原因。
		因为硬件设备的区别，前进消息并不是平均分配在所有帧当中，有的多有的少，所以角色在不同帧中移动的举例不同，造成了角色移动卡顿的现象。
	解决方向：
		要求按下前进按钮角色匀速前进，不要卡顿。即要确保角色在每一个游戏帧中都连贯的移动相同距离。
	解决办法：
		根据实际需求设定不同方向的移动状态m。当前进按钮按下时，则当前方向m为true，表示移动；当前进按钮抬起时，则m为false,表示停止。
		则设置代码，当m为true时，角色坐标按照设定速度变话即可。这样每一帧的移动距离都相等。
		因为不再检测每一次按钮按下的状态，所以就不会因为每一帧检测到的按下次数而导致卡顿了。

	问题4：
		角色移动时，因为移动举例过快，导致跳过移动方向上的障碍物出现在障碍物后方。没有触发撞击。
	问题分析：
		角色移动时，每个循环中就是对角色坐标的修改。即角色实际是通过"瞬移"完成移动的。刚好有障碍物出现在两次瞬移前后坐标之间，且没有与角色重叠，所以没有撞击。
	解决办法：
	
学习总结：
	1、通过角色状态修改来改变角色的行为。
		应该：外部改变--数据改变--角色行为改变
		而不是：外部改变--角色行为改变
	2、所有的行动，都统一用时间作为速度的锚地而非用帧率。这样就不会收到帧率波动影响表现。
		