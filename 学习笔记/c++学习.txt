编程语言本质是和机器交流的工具。

C和C++
	c++(c plus plus)是c的扩充集,c++是兼容c的,c不兼容c++
	c语言的头文件一般都有.h后缀名
	c语言规定所有的变量的定义语句(定义并初始化语句)必须写在函数的最开始，c++则允许变量定义在程序的任何地方
	c语言是以函数为主题，面向过程的编程语言，c++是以类和对象为主体，面向对象的编程语言。但是，具体使用哪种思想编程和语言没有必然联系。
		面向过程：
			提出问题----分析问题----处理问题
			大问题----小问题
			上一个问题----下一个问题----做完问题
			有点：
				逻辑清晰有条例，整体结构简单
			缺点：
				数据和函数是分开的散乱的，没有很强的关联性，数据一旦有修改，维护起来就比较麻烦
				定义的数据各处都能访问，都是公开的，不够安全，容易被篡改，数据不具备封装性
				相互之间联系紧密，不同开发者之前容易相互干扰，比如标识符重名等
		面向对象：是面向过程编程思想的继承和发展。
			中心思想：现实世界是由对象组成的。对象在程序中抽象属性和行为，对应者数据和函数。
			特点：
				将数据和函数结合到一起，方便维护和拓展
				抽象，封装，继承，多态
			优点：
				易维护，易拓展，代码重用率高，安全性好
	c++句式非常灵活，方便阅读时可以随时提行写代码的，程序员要学会辨别，以及方便自己使用。

C++可以的应用方向：
	游戏程序，桌面程序，服务器和系统级别开发

开发工具：	VS Visual Studio 集成开发环境
在VS中创建C语言文件，可在创建.cpp文件时，修改后缀为c。C++ 是 C 的超集，都能运行。
快捷键：
	注释多行：选中代码后按 Ctrl + K，然后 Ctrl + C
	取消注释：选中代码后按 Ctrl + K，然后 Ctrl + U
	框选模式：		Alt + 鼠标拖动， 如果 Alt 键冲突（如某些输入法），先关闭输入法再试
	键盘精细选择：	Shift + 方向键

电脑基础知识：
	存储单位：
		bit		计算机最单位（位）	里面存储非零即一
		byte	计算机最小存储单位（字节）1 B（byte） = 8 b（bit）	可以表示256个数据
		KB		1 KB = 1024 B
		MB		1 MB = 1024 KB
		GB		1 GB = 1024 MB
		TB		1 TB = 1024 GB
		PB		1 PB = 1024 TB
		EB		1 EB = 1024 PB
		ZB		1 ZB = 1024 EB
		YB		1 YB = 1024 ZB
		BB		1 BB = 1024 YB
	内存分类：
		概述：系统为程序开辟内存时，将内存划分为一下四块：
		栈内存：
			作用：用于存储局部变量，函数形参
			分配：由系统自动分配和释放，当块（复合语句、函数体）执行完毕后自动释放内存。
		堆内存：
			作用：用于动态内存的开辟
			分配：由程序员手动申请开辟和释放，如果没有释放，则由操作系统回收（关机）。
		全局数据区（全局静态常量区）：
			作用：存放全局数据、静态变量、字符串常量等等
			分配：程序结束由系统自动释放
			还可以细分为：
				静态内存：
					作用：用于存储全局变量和静态局部变量
				常量内存：
					作用：用于存放字符串字面常量等常量
		代码区：
			作用：存放可执行的代码
			
	进制：
		十进制：		0	1	2	3	4	5	6	7	8		9		10		11		12		13		14		15	
		二进制：		0	1	10	11	100	101	110	111	1000	1001	1010	1011	1100	1101	1110	1111
		八进制：		0	1	2	3	4	5	6	7	10		11		12		13		14		15		16		17
		十六进制：	0	1	2	3	4	5	6	7	8		9		A		B		C		D		E		F
		进制转换：
			十进制转n进制：十进制数连续除以n，求倒叙余数。
			n进制转十进制：设一个n进制数为12…3（有m位数），则其十进制数为：1*n^(m-1)+2*n(m-2)+…+3*n^(m-m)
			二进制和八进制：从右到左，每三位2进制数对应一位8进制数（如上表），顺序对应即可。
			二进制和十六进制：从右到左，每四位2进制数对应一位16进制数（如上表），顺序对应即可。
			其他进制转换：可先转成十进制后再转换。八进制和十六进制可先转成二进制后再转换。
	【注意】C++代码中不存在2进制常量。所有数字常量默认为十进制，0x开头表示16进制，0开头表示8进制，要注意区分。
		
关键字：特殊指令，系统占用的，有特殊用途的，不能用于其他用途的单词或字符组合。
	类型说明符：	
		基本数据类型：（32位）		名称				大小			取值范围						字面常量
			布尔类型(bool)
				bool			bool类型			1字节		只有true和false两个值			true false		【注意】只有c++才有bool类型。用来描述‘真’‘假’
				【注意】bool类型赋值时，如果赋值为true和false以外的值，都遵循“非零为真”的原则，转换为true或false赋值
			字符类型(chart)：
				chart			字符型			1字节		-128~127					'a'				【提示】普通字符常量默认为chart类型
				unsigned chart					1字节		0~255						'a'
				wchat_t			双字符型			2字节									'好'w
				由《ASCII码》人为规定了0~255代表了固定的字符
				【记忆】常用的编码应该记住：'a'-97		'A'-65		'0'-48
				注意：字符型可以当做小整型来用。
				【注意】单引号修饰，且只能修饰一个字符，不能是多个字符。
			整数类形(int)：
				short			短整型			2字节	-32768~32767
				unsigned short					2字节	0~65536
				int				整形				4字节	-2147483648~2147483647			123				【提示】普通整数常量默认为int类型
				unsigned int					4字节	0~4294967296					123U	123u	
				long			长整形			4字节	-2147483648~2147483647			123L	123l
				unsigned long					4字节	0~4294967296					123UL	123uL	123Ul	123ul
				注意：可能在不同系统里面，整形实际大小有变化。但是，规定short不会大于int，long不会小于int。
			浮点数类型(double)：
				float			单精度浮点型		4字节									12.5f	12.5F
				double			双精度浮点型		8字节									12.5			【提示】普通浮点数常量默认为double类型	
				long double		长双精度浮点型	8字节									12.5L	12.5l
				注意：绝大多数情况下，float都能满足精度使用
			无类型(void)
			自动类型推导(auto)
			表达式类型推导(decltype)
			【注意】所有包含long的数据类型，64位系统下字节大小都是32位系统的2倍
			取值范围公式：（N表示该类型占据的位数（字节数*8））
				有符号：-2^(N-1) ~ 2^(N-1)-1
				无符号：0 ~ 2^N-1
			超出取值范围计算公私：（N表示该类型占据的位数（字节数*8））
				当前值的十进制数 > 取值范围上限 -> 减去2^N，直到减到取值范围内；
				当前值的十进制数 < 取值范围下限 -> 加上2^N，直到加到取值范围内；
		类型修饰符
			signed			有符号类型						因为c++中默认有符号类型，所以基本不用		
			undigned		无符号类型
			shuot			短整型
			long			长整型/双精度扩展
			const			常量
			volatile		易变量（防止优化）
			mutable			允许const成员函数修改的成员
		复合数据类型（自定义数据类型）
			struct			结构体		
			union			联合体		
			enum			枚举				c++11新增enum class
			class			类			
			using			类型别名			替代typedef
		储存类型
			static			静态存储期
			extern			外部链接
			register		建议寄存器存储（C++17弃用）
			thread_local	线程局部存储（C++11）
		流程控制
			if/else			条件分支
			switch			多路分支
			case			分支标签
			default			默认分支
			for				for循环
			while			while循环
			do				do循环
			break			跳出循环/switch
			continue		跳过本次循环
			goto			跳转（慎用）
		函数相关
			return			返回值
			inline			内联函数建议
			virtual			虚函数
			override		显式重写（C++11）			仅在特定位置有效。
			final			禁止重写/继承（C++11）		仅在特定位置有效。
			noexcept		声明不抛异常（C++11）
			constexpr		编译期常量函数（C++11）
			consteval		强制编译期执行（C++20）
		面向对象
			public			公有继承/成员
			protected		保护继承/成员
			private			私有继承/成员
			friend			友元
			this			当前对象指针
			operator		运算符重载
			explicit		禁止隐式转换
		模板与泛型
			template		模板声明
			typename		模板类型参数（或依赖类型）
			requires		概念约束（C++20）
			concept			定义概念（C++20）
		异常处理
			try				异常捕获块
			catch			异常处理
			throw			抛出异常
		内存管理
			new				动态内存分配
			delete			动态内存释放
			nullptr			空指针（C++11）	优先使用 nullptr 替代 NULL
		多线程（C++11起）
			thread_local	线程局部存储
			atomic			原子操作（需头文件<atomic>）
		模块与协程（C++20）
			import			导入模块
			module			定义模块
			co_await		协程挂起
			co_yield		协程返回值
			co_return		协程返回
		其他
			sizeof				获取类型大小
			alignof				获取对齐要求（C++11）
			typeid				类型信息（RTTI）
			dynamic_cast		动态类型转换
			static_cast			静态类型转换
			reinterpret_cast	重解释类型转换
			const_cast			去除const属性
		空类型
		【记忆】不同数据类型和零值的比较语法
			布尔类型
				bool a;
				if(false == a)
					cout<<"为0";
			整数类型
				int b;
				if( 0 == b)
					cout<<"为0";
			浮点数类型
				double c;
				if( c>-0.0001 && c<0.0001 )
					cout<<"为0";
			指针类型
				int* p;
				if( NULL == p )
					cout<<"为0";
		【注意】所有的数据在内存中都是以二进制方式储存，在内存中是没有类型之分的。数据类型本身是人为的定义。
				所以，我们使用内存数据时，可以通过类型去内存中获取相应的内存大小的值，转成类型数据。
	语句定义符：
	存储类型符：
	其他：
标识符：用来标识某个实体的符号。简单说就是给变量、符号常量、函数、复合数据类型等取的名字就是标识符
	命名规则及规范：
		只能由字母（a-z， A-Z）、数字（0-9）和下划线（—）组成，且不能由数字开头
		不能和关键字相同
		区分大小写：不同的大小写对应不同的标识符
		有长度限制：	不强制要求，但是要有规范意识
		望文生义：	不强制要求，但是要有规范意识
		中文标识符：	VS2005开始就能使用中文做标识符，不推荐。也许会在别的平台或环境报错。
		可以下去了解匈牙利命名法，这是业内惯用的命名规则。
		
常量和变量：
	常量：不能被修改的量（数据）
		普通常量：
			数值常量：
				整数常量（默认int类型）：10，-5，123
				浮点数常量（默认double类型）：3.24，0.99
					float类型的常量需要加上f：1.23f
			字符常量：'a'，'D'		单引号修饰
			字符串常量："aDc"，"a"	双引号修饰
		转义字符（用\表示转义）：\n（换行）,\t（水平制表=4空格）,\\（表示\）
	变量：
		概述：
			程序员是和内存打交道的职业，和内存数据的交流的手段是变量。
			变量是指在内存中开辟相应的内存空间用于存储数据。
			变量的本质是内存。是可以被修改的量（数据），常量可以用来给变量赋值。
		定义：数据类型 变量标识符;
			例：	int a;			定义一个名字为a的int类型变量，这里未初始化表示未知值。
								从内存方面解释:在内存中连续开辟4个字节内存，取名为a，这片内存的运算规则是整数运算规则（只能存储整数）。
								内存地址由操作系统决定
								开辟：告知系统这片内存为我所用，其它程序(包括自身)不得再开辟
				int b = 10;		定义一个名字为b的int类型变量并初始化为10。推荐在定义时就初始化。
				c = 10;			【注意】变量在使用之前必须先定义！所以这里错误
				a += 16;		【注意】变量在操作（包括但不限于参与运算和赋值）之前必须先初始化！所以这里错误
								【总结】一般情况之下变量的默认值是危险的，无法使用
										让变量有值的方法叫赋值
										初始化(定义并赋值)
			定义数值变量时，默认为有符号数。如果用unsigned修饰，则为无符号数（非负数）
				unsigned int a = 100;	此时不能变量a赋值负数
				int b = 0;				b可以被赋值正负数和0
			负整数的存储方式：
				有符号数在内存中，第一位是符号位，为1表示有符号（-）为负数，0为无符号，非负数。
				char a = 1		a在内存为 0000 0001
				char b = -1		b在内存中的计算方式：数值-1的绝对值的二进制数，取相反数，再+1
								即：-1的绝对值为1，二进制为 0000 0001
									取相反数，按位取反为：	1111 1110
									再+1，为：				1111 1111
								所以b在内存中存储为：1111 1111。
		变量和作用域
			全局变量：
				在所有函数外部定义的变量（通常是在程序头部），成为全局变量。
				作用域：在声明之后的整个程序。可以被任何函数所访问。
				内存的开辟和释放：程序在进入入口点函数之前在静态内存区分配内存，在退出入口点函数之后释放内存。
				声明：extern关键字
					程序中一般不会只有一个代码文件，一般在头文件.h里面声明全局变量。
				格式： extern int a;
				【陷阱】extern int a = 0;	初始化后这就是定义语句而非声明了，要尽量避免。
				定义：在声明之后，再在其他.cpp文件中定义。
					int a = 0;这是定义并初始化。如果没有初始化则默认为0。
					【注意】全局变量的声明可以多次，但是定义只能有一次。	
			局部变量:
				凡是定义在函数内部的变量都叫局部变量。
				作用域：从其定义语句开始到直接包含它的大括号结束。局部变量只能在其作用域范围内被访问。
				内存的开辟和释放：在程序执行其定义语句时在栈内存中开辟内存，在程序退出其作用域时释放内存。
				【常识】函数的形参也是一种局部变量。在调用该函数时开辟内存，在程序退出作用域时释放内存。
				【记忆】局部变量如果没有初始化系统是不会自动初始化的，此时输出该变量会报错。请养好初始化变量的习惯。
			静态局部变量：
				为了实现某些特殊功能，将内存开辟在静态内内存区的局部变量。
				格式：static int a;
				作用域：从其定义语句开始到直接包含它的大括号结束。
				内存的开辟和释放：在程序第一次执行定义语句时在静态内存区开辟内存，
								  在退出入口点函数之后释放内存。
				【注意】静态局部变量如果没有初始化则自动初始化为0。	
			静态函数和静态变量	static
				定义：	关键字static修饰的变量和函数为静态变量和静态函数
				格式：	static 数据类型 变量名；
						static 返回值类型 函数名(形参列表);
				静态变量：使用域为局部，生存域在全局。不会在块结束时被释放掉。
				静态函数：修饰函数在当前文件有效。
					【注意】函数的作用域默认时全局的。只要有导入头文件，项目哪里都市能用的。
			【记忆】static关键字的作用
				修饰局部变量：则被修饰的局部变量称为静态局部变量。在程序第一次执行定义语句时在静态内存区开辟内存，在退出入口点函数之后释放内存。
				修饰全局变量或函数：则被修饰的全局变量或函数其所在的源文件中的其它函数访问。
				修饰类中成员变量： 则被修饰的类成员变量称为静态成员变量。静态成员变量的内存开辟在静态内存区，程序在进入入口点函数之前分配内存，
								在退出入口点函数之后释放内存，所有的类对象都共享一份静态成员变量。
								【记忆】静态成员变量必须显示定义,未初始化则默认为0。
									变量类型 所在类名::变量名 = 常量;			
				修饰类中成员函数：则被修饰的成员函数称为静态成员函数，没有this指针，且只能访问类中静态成员变量。
			【记忆】extern关键字在C++语言中的作用
				作用一是用于声明全局变量；
				作用二是告知C++编译器，某些函数是被C语言编译器编译出来的，这样C++就能通过正确的名称来链接C语言编译器编译出来的函数了
	常变量：用const关键字修饰的变量
		定义格式：	const 数据类型 变量名;
			注意：常变量定义时必须初始化赋值。例：const char sex = 'm';
				因为常变量在定义后就和常量一样不能被修改和再赋值。所以只能且必须在定义时赋值。
	引用：
		定义：对一个变量或者对象取的别名叫引用。定义引用时必须初始化
		格式：
			int a;
			int& b = a;		// 定义b为a的别名  &表示这里时定义一个别名
		【注意】引用只是一个别名，不存在单独的内存。对引用的操作完全等同于被引用的变量或对象。
		使用方法：有别变量或对象名字特长，在使用时可以声明一个短名引用。
		
运算符：
	定义：说明特定操作的符号
	分类：
		按照功能分类：
			算数运算符：数学计算，返回计算的结果
				+	加
				-	减
				*	乘
				/	除		
					整除：两边操作数都是整形，则结果留商舍弃余数。例如 10/3，结果为3
				%	求余		【注意】只能是整数进行操作，结果取余数舍弃商
					常见用法：
						用法一：x + y * w = 下标  x = 下标 % w   y = 下标 / w;
						用法二：求a以内的随机数  rand() % a 
						用法三：求a到b（a<b）之间的随机数 rand() % (b-a) + a
						用法四：用宏求a到b（a<b）之间的随机数: #define S(a,b) (rand()%((b)-(a)) + a)
			自增运算符（单目）：++  --
				运算符前置：先计算，再返回。可作为左值进行嵌套运算。
				运算符后置：先返回，再计算。不可作为左值操作。
			赋值运算符：
				=
				【注意】1、左操作数必须是变量，右操作数可以是变量，可以使常量，也可以是临时量。
					   2、左右操作数的数据类型必须一致，或者经过转换后一致。
			自赋值运算符：
				+=		a += b	等同于	a = a + b	一下符号以此类推
				-=
				*=
				/=
				%=
				&=
				^=
				<<=
			关系运算符：判断两个变量关系是否成立。0为假，非0为真
				>	大于
				>=	大于等于
				<	小于
				<=	小于等于
				==	等于
				!=	不等于
			逻辑运算符：返回逻辑运算结果。0为假，非0为真
				&&	逻辑与	并且		真真为真，有假为假。
				||	逻辑或	或者		有真为真，假假为假。
				!	逻辑非	非		非真即假，非假即真。	注意：0为假，!0为真
				【注意】优先级：！> && > ||
				【陷阱】优先级高不等同于要先运算。
			位运算符：多用于底层操作
				&	位与		操作数都为1，结果为1，其他为0
				|	位或		操作数都为0，结果为0，其他为1
				~	位非		操作数为0，则结果为1，操作数为1，则结果为0
				^	位异或	两个操作数不同，结果为1，其他为0；					
				<<	位左移	将左操作数转成二进制，数据位左移右操作数表示的位数，最左溢出丢弃，最右都补0
							左移n位，等于左操作数乘2的n次幂
				>>	位右移	将左操作数转成二进制，数据位右移右操作数表示的位数，最右溢出丢弃，正数最左补0，负数最左补1
							右移n位，等于左操作数整除2的n次幂
			取字节运算符：
				sizeof()	求数据内存大小，返回一个int类型整数
						sizeof(类型说明符) 如：sizeof(int)、sizeof(int*)、sizeof(char*)等等。
						sizeof(变量名)
						sizeof(常量)
						sizeof(表达式)
				【记忆】计算流程
					sizeof("sdfadfd")
					sizeof(数组名) 
					sizeof(表达式)/有隐式转换:
								  \无隐式转换:变量,指针,地址[0],*地址,&变量,&地址[0],*地址[0],
											  /结果是地址/char类型地址
											  \		     \非char类型地址
											   \结果不是地址
					sizeof(char类型指针)			结果=4
					sizeof(char类型数组名)		结果=数组长度*sizeof(数组类型)
					sizeof(字符串字面常量)		结果=字符串字面常量占据的大小
					sizeof(地址)/char类型地址	结果=字符串字面常量占据的大小	
								\非char类型地址 	结果=4
					【注意】一个特殊情况：
						cout<<sizeof("123456"+10); \这三种情况都可以直接看做cout<<sizeof("123456"); 实际上并没有参与运算。
						cout<<sizeof("123456"-10); /
						cout<<sizeof(10+"123456");/
			条件运算符（三目）：
				?:		a?b:c		a如果为真，则执行b，为假则执行c
				【注意】条件运算符可嵌套计算。
			逗号运算符：
				，	从左到右依次执行各个操作数，最后返回最右侧的操作数
					举例：int m = a,b,c,d,e	会一次执行a、b、c、d、e操作数，并最终给m赋值e的返回值。
					【陷阱】赋值、逗号、括号同时出现
						逗号出现在定义语句是用来分隔多个变量的。	// int a = 1, 2; 错误！  int x,y; 正确 int i = 0, j = 0; 正确 
						逗号出现在非定义语句是逗号运算符。			// int a = (1, 2);	这里是逗号运算符
																// a = 1, 2;		这里是分隔符	【注意】数字可以单独作为一条语句，不报错。
						逗号运算符的结果返回的是逗号后面的表达式。
						优先级：其他运算符 > 赋值运算符 >逗号运算符
			下标运算符：[]
				一般用于表名后面表示表的第几个元素。常用于数组名后面表示返回数组的第几个元素。
			【注意】内置运算符
				new
				delete
				这两个关键字是运算符，不是函数
			【注意】运算符的操作数，即可能是变量、常量，也可能是表达式。
		按照修饰的操作数的个数分类：
			单目：
			双目：
			三目：只有三目条件运算符
	运算符的结合性和优先级：
		结合性：指从哪边开始计算
			大部分从左往右运算
			少部分从右往左：逻辑非、按位非、前缀自增减、正负、C风格转型、取大小、取地址、指针访问、动态内存分配、三元条件、赋值运算
		优先级：圆括号为最优先级，因此习惯使用圆括号，可以避免大多数优先级错误。
		---------------C++运算符优先级表--------------------
		优先级	运算符		说明
		1		++   --		后缀自增/后缀自减
				()			括号
		2		++   --		前缀自增/前缀自减
				+   −		正/负
				!   ~		逻辑非/按位取反
				(type)		强制类型转换
				sizeof		取字节
		3		*   /   %	乘/除/取模
		4		+   −		加号/减号
		5		<<   >>		左位移/右位移
		6		<   <=		关系运算符：小于运算符/小于等于运算符
				>   >=		大于运算符/大于等于运算符
		7		==   !=		等于运算符/不等于运算符
		8		&			按位与运算符
		9		^			按位异或运算符
		10		|			按位或运算符
		11		&&			逻辑与运算符
		12		||			逻辑或运算符
		13		?:			条件运算符
		14		=			赋值运算符
				+=   −=		自赋值运算符
				*=   /=   %=	
				<<=   >>=	
				&=   ^=   |=	
		15		,			逗号运算符
		
表达式：
	定义：一种右值的语法结构，由运算符将变量和常量结合而成。
	【重点注意】变量可以改变其数据类型。在不同类型数据进行混合运算时会用到强制转换和隐式转换。
		【理解】转换中数据在内存中的变化：可看成赋值，将一个数值赋给一个变量。若数值超过了变量的取值范围，则视为超界赋值运算。
		隐式转换（自动转换）：
			【记忆】会发生隐式转换的情况：
				赋值运算符两边数据类型不一致时，会将右边数据类型的值转为左边类型后再赋值。
				有不同的数据类型参与一个共同运算的时候。
			【规则】
				不足4字节的转int类型
				低字节转高字节
				低精度转高精度
				有符号转无符号
			【陷阱】隐式转换原则里面的小于4转int，但是如果是关系或者逻辑运算则结果就不是int而是bool了
			【注意】隐式转换中有矛盾的地方一般会有警告。
		强制转换：大类型转小类型（会丢失数据）
			格式：（a类型名）b变量/常量		即将变量b转换为a类型数据
			【注意】强转只能作为右操作数操作，且注意是b的值会转换成类型a。但并不代表变量b被转换成类型a了。
			【注意】对于基础数据类型，VS会自动强制转换。但实操时建议加上强制转换语法。

语句：一行行代码指令，通过分号结束的。计算机通过执行一条条语句来实现程序运行。
	定义：程序运行时执行某个动作的语法结构
	分类：
		空语句：			只有一个分号，什么也不执行
		表达式语句：		在表达式的末尾加分号
			注意：a+b；	这种是语句，但不是有用的语句。
		函数调用语句：	由函数名、实际参数和分号组成
		符合语句：		使用{}将一系列语句括起来，相当于一条语句
		控制语句：		分支、循环、跳转

流程控制：
	代码执行流程：C语言中，代码要写在main函数里面才能被执行。在没有遇到控制语句时，默认从上往下，从左往右，依次执行
	控制语句：在写代码过程中，只有顺序结构是不够的，还需要一些控制语句
		分支
			if语句
				if(关系/逻辑/算术表达式)		注意：算术表达式的话，非0即为真
					...
			if...else...语句
				if(关系/逻辑/算术表达式)		注意：else不能脱离if单独使用，默认和前面最近的if匹配。可嵌套
					...
				else
					...
			if...else if...语句
				if(关系/逻辑/算术表达式)		
					...
				else if(关系/逻辑/算术表达式)
					...
				...
				else						
					...
				
			switch...case...语句	
				switch(算术表达式)			这里的算术表达式应该返回一个整数结果
				{
					case 值1:语句；break；	如果case后面的值与上面表达式的值匹配，则执行后面的分支语句
					case 值2:语句；			【注意】case只表示一个分支入口，但整个{}内都是内容。代码会从分支入口一直执行到{}内容结束。
					case 值3:语句；break；	如果只要求执行某分支就结束，则应该在分支语句后加上break（跳出），跳过后续内容。
					...
					defaule:语句；			如果case的值和表达式都不匹配，则执行default分支语句。这里break可加可不加
				}
				
			if...else if... 和switch...case...的区别
				前者适用于范围表示，后者适用于值表示。switch也可以用整除，来表示一定范围的值
		循环
			for
				语法：for(表达式1；表达式2；表达式3){循环体内容；}		【注意】如果圆括号后面加分号，则表示for循环修饰一个空语句，所以不要加分号。
					表达式1		计数变量										可缺省，表示什么都不做
					表达式2		计数限制条件(为真则执行循环，为假则结束循环)	可缺省，表示为真，可无限循环（注意死循环）
					表达式3		计数变量的改变								可缺省，表示什么都不做
				【注意】三个表达式可以缺省，但是两个分号不能缺省
				执行流程：表达式1-->表达式2-->循环体-->表达式3-->表达式2
			while
				语法：while(关系/逻辑/算术表达式){循环体内容；}		
				【注意】和if一样，这里的算术表达式非0即为真，圆括号后面不加分号
				【注意】while相当于for循环缺失了表达式1和3，所以需要在循环前准备好计数变量，且在循环体内做计数变量修改。
			do while
				语法：do{循环体内容；}while(关系/逻辑/算术表达式)；
				【注意】do...while...相当于while先执行一遍循环体，再判定计数限制条件。所以可能在条件一致时，比前两者多执行一次循环体。
				【注意】while后面的圆括号必须加分号，前两者加了表示循环体为空语句。	
		跳转
			break
				跳出当前循环或switch语句，结束循环或switch语句执行
				【注意】只能跳出一重循环或者switch语句
			continue
				作用域循环中，结束当前本次循环，直接进入下次循环
				【注意】for循环的话，是跳过循环提内容，到达表达式3，再判断下一次循环
			goto
				语法：goto 标号		例下：
					int i = 0;
				MYLAB:							// 标号，要顶格写，需要加冒号，大写字母
					printf("",++i);
					goto MYLAB;					// goto+标号，即程序跳转到该标号处，再往下继续执行。
				【注意】C语言中不限制程序里使用标号的次数，goto又可以无条件跳转到标号处，所以极大可能导致代码混乱。不建议使用！
				【注意】也有程序员将goto用于多重循环的跳出，这还是比较方便的。
数组：
	定义：固定大小的相同类型元素的顺序集合
	【注意】数组要格外注意下表越界，即访问了数组范围之外的数据。
	一维数组：
		定义：数据类型 数组名[数组长度]
			例：int arr[10];			定义了10个int类型数据组成的一个数组，数组名为arr。
									【注意】数组长度不能是变量，只能是常量或者常量表达式！
		初始化赋值：
			方式1：定义数组时给出所有元素的值。数组元素放在花括号里。
				例：	int arr[3] = {1,2,3};
			方式2：定义数组时给出部分元素的值，其他元素为0值。
				例：	int arr[6] = {1,2,3};		这里默认是依次从第一个元素开始赋值
			方式3：定义数组时给出所有元素的值，可以缺失数据长度（最高维）。
				例：	int arr[] = {1,2,3};		这里会更具右操作数，自动将数组分配为三个数据长度。
		元素访问：数组名[下标]
			例：	arr[0];				返回arr数组中第一个数据。【注意】数组下标是从0开始，所以下表取值范围为[0,数组长度)。
				arr[1]=1;			给数组中下标为1（也就是第二个）的数据赋值为1。
			对数组某个数据进行访问或者操作，可以通过数组下标。
			【遍历】对数组所有数据进行访问，则可以用循环语句。
		
	二维数组：可看作n个一维数据的集合，但在内存中其实和一维数组类似，也是连续存储。
		定义：数据类型 数组名[一维数组长度][二维数组长度]		可以将二位数组看成矩阵：数据类型 数组名[行][列]
			例：	int arr[3][4];		表示有3行，每一行就是一个4个类型长度的一维数组。3行4列。
		元素访问：
			数组名[一维下标][二维下标]
			例：	arr[0][0] = 1;
				arr[3][2] = 2;
			【注意】有的编辑器二维数组继可以用一维数组的方式访问，如下所示。但是强烈不建议这么做。有时候这样读出来的时一个数组指针，且非常容易越位。
				int arr[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};	
				int a = arr[6];			//返回值为7
				另，假设一二维数组行列分别是a,b要取值第n位数据，则arr[n] 等同于 arr[n/a][n%b];
					例：
						int arr[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};	
						arr[5] 和 arr[5/3][5%4] 就是取的同一个数据：6	。
			【遍历】对数组所有数据进行访问，则可以用双重循环语句。
		初始化赋值：
			方式1：定义数组时给出所有元素
				int arr[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};		三个一维数组组成
				int arr[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};			也能视为一个一维数组做初始化
			方式2：定义数组时给出部分元素的值，其他元素为0值
				int arr[3][4] = {{1},{2},{3}};
				int arr[3][4] = {1,2,3};
			方式3：定义数组时给出所有元素的值，可以缺失数据长度（最高维）。
				int arr[][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
				int arr[][4] = {1,2,3,4,5,6,7,8,9,10,11,12,13};		【注意】这里会变成4行4列。总数组长度会除以列数，商向上取整，就是行数。
		【注意】二维数组的第二维越界访问，只要没有越界到整个二维数组外面，所以也能读取到数据。但是都不建议这么做！！！无论几维都不要越界！
			例：int arr[3][4] = {1,2,3};		
				arr[0][14]、arr[2][5]	会报错下标越界
				arr[0][11]、arr[1][7]	这里第二维下标越位，实际都读取的arr[2][2]的数据，是没有越界到整个二维数组外面，所以也能读取到数据。
	
	三维数组：可以看作n个二维数组的集合。
			一维可看作队列，只有长度一个下标；二维是方阵，有长宽两个下标；三维是楼房，有长宽高三个下标。
		定义：数据类型 数组名[一维数组长度][二维数组长度][三维数组长度]
			例：	int arr[3][4][5];		表示有3行4列5高。
		元素访问：
			数组名[一维下标][二维下标][三维下标]
			【遍历】对数组所有数据进行访问，则可以用三重循环语句。
			
	其他N维数组：可以看作多个n-1维数组的集合。
		定义：数据类型 数组名[一维数组长度][二维数组长度]...[N维数组长度]
		元素访问：
			数组名[一维下标][二维下标]...[N维下标]
			【遍历】对数组所有数据进行访问，则可以用N重循环语句。
	
	字符数组（字符串）：
		定义：多个字符组成的数组。在C语言中，用字符数组来表示字符串。字符串中用'\0'表示字符串结束。
		初始化：除了常用数组初始化方式外，还可以直接使用字符串初始化（C语言风格）。
			普通方式：		char name[16] = {'z','h','a','n','g','s','a','n'};
			字符串初始化：	char name1[16] = "zhangsan";
			【注意】字符用单引号修饰，字符串使用双引号修饰。
			【注意】字符串的实际长度，至少要比实际字符个数多一，用以存放'\0'。
					例：char n[8] = "zhangsan";
						printf("%s\n",n);		// 因为没有留够'\n'的存放空间，输出n时会计算机会越位，将数组以外的数据当作字符输出，直到遇到'\0'为止。
		求数组内存大小
			char name[16] = "zhangsan";
			printf("%d\n",sizeof(name));		//16
		求字符串长度
			char name[16] = "zhangsan";
			printf("%d\n",strlen(name));		//8
			【注意】字符串长度，是指从下标0开始，一直到\0，中间有多少个字符
				char name[16] = {'z','h','a','\0','g','s','a','n'};		printf("%d\n",strlen(name));		//字符串长度为3，但是大小还是16
				char name[16] = {'\0','h','a','\0','g','s','a','n'};	printf("%d\n",strlen(name));		//字符串长度为0，但是大小还是16
		C++风格定义字符串：
			创建方式：string a = "abc";
			【注意】一定要记得包含头文件：#include <string>
	字符二维数组：也可以叫字符串数组
		char name[3][16] = {"zhangsan","lisi","wangwu"};

函数：是完成一定功能的代码，在很多高级语言里也叫“方法”
	 相同的代码（功能）可以封装成函数
	函数的内容：
		返回值类型	功能结束后是否得到一个结果
			void	无类型	表示不需要结果	如果需要结果，则函数体里需要用return+表达式返回。
		函数名（标识符）
			用来表示是哪个函数
		参数列表(形参列表)
			用来表示在这个函数中需要用到哪些参数，多个参数用逗号隔开
		函数体
			用来编写函数的执行代码，是实现功能。写在花括号中，花括号不能省略！
	定义的基本格式：
		返回值类型 函数名(形参列表)
		{
			函数体;
			return 表达式;
		}
	函数的声明：	返回值类型 函数名(形参列表)；
	实参和形参：函数调用时，系统会将实参的值传递给被调用函数的形参。
		定义和作用
			形参：
				定义：函数定义时，参数列表中的是形参。没有具体的值，用以代指某一类型的变量。
				作用：在函数体中用来描述一个数据变量的变化执行流程。
			实参：
				定义：函数调用时，参数列表中填入的参数。有具体的值，是函数具体执行时的变量。
				作用：表示函数实际操作的变量的值。
			【注意】实参和形参的数据类型应该相同，且一一对应。实参在函数调用期间有效
			【注意】值传递和地址传递。
				值传递：		指实参是普通变量。实参传递给形参时，传递的是变量的值。函数体对形参的计算不会改变实参的值。
				地址传递：	指实参是地址变量。实参传递给形参时，传递的是变量的地址。函数体能通过形参访问到外部的实参，能改变实参的值。
	占位参：
		用来表名函数的重载，但实际没有特别的意义。
		void fun();
		void fun(int);		// 占位参 标记和前面的函数不一样
	函数的调用：
		调用前的条件：
			如果是库函数，需要先导入头文件
			如果是自定义函数，要么先定义，要么在使用之前先声明
		格式：	函数名(实参列表)；
	函数的嵌套调用：在一个函数中调用另一个函数
		主调和被调：假设A函数里面调用了B函数，那两个函数就是主调和被调的关系。A为主调函数，B为被调函数。
			【注意】被调函数应在主调之前要有定义或声明。
			【注意】函数不允许嵌套定义。
		递归调用：主调函数在函数体内部直接或简介又调用了主调函数。
			【注意】递归函数必然带参数，通过参数来决定是否递归结束。
			【注意】递归也是循环的一种。递归调用要注意结束条件，不然容易进入死循环。
	字符串库函数的调用
		导入头文件：
			#include <string.h>
			导入头文件都是用 #include <文件名.h> 格式。.h是C语言中头文件的后缀名，意思为head
		常用函数：
			char arr1[16] = "zhangsan";
			char arr2[16] = "lisi";
			strlen		字符串长度		int len = strlen(arr);
			puts		字符串的输出		puts(arr);				// 和printf("%s\n",arr);功能相同
			gets		字符串的输入		gets(arr);				// 输入字符串，并给arr赋值。点击回车结束输入。【注意】输入的字符串长度要小于赋值变量的大小。
			strcpy_s	字符串拷贝		strcpy_s(arr1,n,arr2)	// 将字符串arr2拷贝到arr1。【注意】n应该大于arr2的长度，小于等于arr1的容量。
			strcat_s	字符串连接		strcat_s(arr1,n,arr2)	// 将字符串arr2链接到arr1后面。【注意】n应该大于新字符串的长度，小于等于arr1的容量。
			strcmp		字符串比较		strcmp(arr1,arr2)		// 返回值为1，表示arr1>arr2，返回值为-1，表示arr1<arr2，返回值为0，表示arr1=arr2。
						【注意】是依次从第1个字符开始比较。不相等，则返回1或者-1；相等，则比较下一个字符，没有下一个字符，就返回0。
			strstr		求子串			strstr(arr1,arr2)		// 在arr1中全字匹配arr2的第一个下标。没有则返回NULL;有则将arr1下标往后的新字符串。
						【注意】不会修改arr1和arr2。这个函数还可以理解成，将arr1中，第一个arr2之前的内容裁剪掉，然后返回一个新字符串。
	内联函数：
		定义：内联函数在调用时，编译时是直接将函数体复制在调用区域。增加了代码数量，但减少了程序运行时间。
		作用和原理：
			作用：通过增加程序的内存占用，以达到提高程序运行速度的目的。
			原理：
				1、内存有个区域为代码区，内联函数就是让代码区的代码变多，增加了内存占用。
				2、普通函数参数传递本质是创建一个临时变量，涉及到内存的开辟和回收，是比较占时间的。内联函数就省掉这些了。
		格式：
			inline 返回值类型 函数名（参数表）；
			inline 返回值类型 函数名（参数表）
			{
				函数体；
			}
		特点：内联函数的调用和普通函数一样
		使用方式：
			函数体不能太长，以免内存不足；
			函数体内不建议又循环；
			如果是简单的赋值语句，或者代码逻辑简单，使用频率很高，建议写成内联函数；
	函数重载：
		定义：指同一个项目下，有多个函数的函数名相同，即为函数重载。
		要求：
			函数名必须一致
			参数列表必须不同
				参数个数不同
				对应位置上，数据类型不同
		调用：根据参数的不同，程序会自动区匹配相应的函数。如果匹配不到相应的重载函数，则会报错。
	函数参数缺省：
		定义：声明一个函数时，给某个参数指定了一个默认值，那么调用该函数时如果采用默认值，则可以省缺该参数的实参。
		【注意】
			参数列表因为是从前往后顺序传参，所以默认值只能从后往前给。
			如果函数有声明和定义，则只需要声明时设定默认值即可。
			函数重载和参数缺省如果一样，则会报错。
作用域
	作用域定义：一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字可用性的代码范围就是这个名字的作用域。
	作用：提高了程序逻辑的局部性，增强程序的可靠性，减少标识符（命名）冲突。
	【常识】C++允许变量名重复的情况。但是同一个作用域下不允许变量重名。
			编译器识别变量重名按照就近原则识别，以就近的作用域为最优先。
			局部->类成员变量->父类成员变量->全局变量。
			重名情况下要直接访问全局变量时，直接在标识符前加::符号。
			访问变量的方式有： 变量; this->变量; ::变量; 类名::变量;
	【建议】虽然C++允许变量名重复的情况，但是在程序开发中建议遵循相应的标识符命名规范，尽量避免重名情况，提高代码的阅读性和可维护性。
	局部作用域
		代码声明处所在的{}范围之内。
	全局作用域
		在整个程序项目范围类有效的变量，一般定义在文件的开头。
	
定义域和作用域
	作用域和定义域都是用{}来标记的，括号类就是域，都区分等级，括号内为下一级，可以直接访问括号外的上一级。
	作用域用来限定代码执行区域，必须如限定函数体，限定循环体等。定义域用来限定定义范围，比如定义结构体，定义数组等。
	作用域{}后面不加分号，但是定义域{}后面必须加分号，标识代码执行结束。因为作用域的代码执行在{}内结束，所以不用加。定义域{}本身就是执行代码，所以需要加。
	【记忆】一般用到的{}作用域主要集中在函数体、循环体、分支和命名空间定义。

命名空间：是用来组织和重用代码的编译单元。可以通过命名空间来避免或解决重名现象。
	格式：	
		namespace NAME_1	// 命名空间的名字必须是合法标识符
		{
			// 在这里面定义变量函数等
			int a;
		}
		NAME_1::a = 10;	// 访问命名空间里面的变量，要用到作用域符号::
	【注意】命名空间可以定义在全局，可以可嵌套定义在别的命名空间里面，不能在函数里面定义。
	命名污染：
		在同一作用域，定义了相同名字的命名空间，叫做命名污染。命名污染不会报错，可以利用命名污染完善命名空间。
		namespace NAME_1
		{
			int a;
		}
		namespace NAME_1
		{
			int b;
		}
		以上代码可视为：
		namespace NAME_1
		{
			int a;
			int b;
		}
		都是访问的同一片命名空间。
	【小技巧】当命名空间表示符比较长或不方便记忆时，可以取别名以方便使用，简化代码，增加可读性。
		namespace n = NAME_1;

cin和cout
	cin时c++里面的输入对象，类似c的scanf;
	cout时c++里面的输出对象，类似c的printf;
	【注意】这两个不是关键字也不是函数，是对象
	使用方法：
		#include <iostream>				// 必须加载头文件
		using namespace std;			// 声明在这里往下都使用std的命名空间
		/*								// 这样写也可以在不声明using namespace std时省略掉下面的std::。用哪个就声明哪个
		using std::cin;
		using std::cout;
		using std::endl;
		*/
		int num = 10;
		cin >> num;						// cin、cout和endl是存在与std命名空间的，调用时必须加std::，但是前面已经声明为std的命名空间了，所以则可以省略不写。
		cout << num << endl;			// endl的作用是换行
		
预处理
	定义：指在编译前，把源码中一些需要预先处理的内容处理了
		包括 宏、文件包含和条件编译
	【提醒】一般就是#代表预处理指令
	宏
		宏替换：在开始编译前先把宏的内容替换完成
		无参宏
			格式：#define 宏名 替换的字符串
			举例：
			#define PI 3.14		// 代码中所有使用PI的地方，预处理都替换成3.14
			【注意】除非故意，宏是不加分号的。因为也hi算作替换的字符串内容
		带参宏
			格式：#define 宏名(参数)	替换的字符串
			举例：
			#define ADD(a,b) a * b
			printf("%d\n",ADD(5,2));	//替换后结果就是printf("%d\n",5 * 2);
			【注意】有参的宏需要注意替换后的运算符优先级带来的问题。这个问题可以通过加括号来避免
				举例1：
					#define ADD(a,b) a * b
					printf("%d\n",ADD(5+3,2+1));	//替换后结果就是printf("%d\n",5+3 * 2+1);		输出结果就会是12，而不是24。
					因此，推荐加上括号：
					#define ADD(a,b) (a)*(b)
					printf("%d\n",ADD(5+3,2+1));	==>  printf("%d\n",(5+3)*(2+1));  ==>  24
				举例2：
					#define ADD(a,b) a + b
					printf("%d\n",5 * ADD(5+3,2+1) * 2);	//替换后结果就是printf("%d\n",5* 5+3 + 2+1 * 2);		输出结果就会是32，而不是110。
					因此，推荐加上括号：
					#define ADD(a,b) ((a)+(b))
					printf("%d\n",5 * ADD(5+3,2+1) * 2);	==>  printf("%d\n",5*((5+3)+(2+1))*2);  ==>  110
				所以，带参宏最好在每个参数上加括号，计算结果也加上括号
		【注意】宏名一般都大写，一般不会用宏替换关键字
		NULL
			NULL是C中的宏，C++继承了C。传统 C/C++将NULL定义为0或(void*)0，但是可能会引发类型歧义（如函数重载时无法区分 int 和指针）。
			所以C++11 新增关键字 nullptr，明确表示空指针。所以现在推荐优先使用 nullptr 替代 NULL。
			NULL 仅用于兼容旧代码或 C 语言项目。
	文件包含：指当需要使用在别的文件中声明的函数时，需要先声明该函数所在的头文件。一般包括库函数和自定义函数头文件。这就是文件包含。
		【注意】C/C++中的代码规范中，函数尽可能在头.h文件中声明，在.c/.cpp文件中定义。随着项目的增大和管理，也应该如此规范化写代码。
		库函数：C/C++里面有集成了很多库函数，分布在不同的库函数文件中。如果代码中需要引用对对应库函数，就需要导入相关头文件。
			常用的库函数头文件：
				stdio.h			输入输出函数
				string.h		字符串处理函数
				math.h			数学函数
				time.h			时间函数
	
		格式：
			#include <文件名.h>		尖括号表示只会在系统文件中查找文件。多用于导入系统自带的库函数文件。
			#include "文件名.h"		双引号表示先在当前项目所在文件夹中查找，找不到再去系统文件中查找。多用于导入自定义的文件。
		嵌套包含：指一个被包含的文件中，还可以再吃包含别的文件
		【注意】文件不能重复包含，因为会引发重定义的问题。
			解决办法：VS编辑时（其他编辑器不一定有这个），在文件顶行添加 #pragma once
			【提醒】一般库函数头文件都有放置重复包含的，主要时自定义头文件需要注意添加这个。 
	条件编译：根据不同条件编译不同代码
		#if...#else...#endif			//如果表达式为真，则编译代码段1，否则编译代码段2
			#if 表达式
				代码段1
			#else
				代码段2
			#endif
		#ifdef...#else...#endif			//如果定义了宏，则编译代码段1，否则编译代码段2
			#ifdef 宏
				代码段1
			#else
				代码段2
			#endif
		#ifndef...#else...#endif		//如果没有定义宏，则编译代码段1，否则编译代码段2
			#ifndef 宏
				代码段1
			#else
				代码段2
			#endif
			
		【注意】VS以外的编辑器，能通过条件编译实现#pragma once的效果
			例子：先假设当前头文件名为 myhead.h 则在文件中这样写：
			#ifndef _MYHEAD_H_				//	检测项目是否没有定义宏_MYHEASD_H_，如果为真，则继续编译，为假则跳到#endif编译
			#define _MYHEAD_H_				//	定义宏_MYHEASD_H_
				(这里编写头文件正式内容)
			#endif
		【注意】#else不是必须有的。可根据自己实际情况编写代码

自定义数据类型：由于基础数据类型可能不能满足实际的项目需要，所以程序员可以自行定义需要的数据类型。
	【注意】在C里面，定义自定义数据类型变量也需要加相关关键字，但是C++就不用
	结构体：将多个数据封装成一个数据类型
		结构体类型定义
			struct 结构体类型名{成员列表};		// 定义后面要加分号
				struct M
				{
					int a;
					int b;
					...
				};
		结构体变量定义和初始化：
			定义结构体对象变量（3种）
				1、定义结构类型同时定义变量
					struct 结构体类型名{成员列表} 变量名 = {...};		【注意】初始化时{}中的数据是依次按照顺序给成员变量赋值
						struct M
						{
							int a;
							int b;
							...
						} m = {...};
					struct {成员列表} 变量名 = {...};		【注意】当结构体类型名省缺时，无法通过类型定义新的变量，但可用于单例模式。不推荐日常使用。
						struct
						{
							int a;
							int b;
							...
						} m = {...};
				2、已定义结构类型后，定义变量
					结构体类型名 变量名 = {...};
						M m = {1,2,...};
			定义结构体指针变量
				结构体类型名* 指针名；
				M* p = &m;
		结构体变量的成员访问
			变量名.成员变量			m.a;
			变量名指针->成员变量		p->a;
		类型重定义：用新的类型名，都替代原有的类型名。关键字typedef
			格式：typedef 原类型名 新类型名;
			用途：类型名改短、类型名更易识别
			【注意】typedef可以重定义所有类型，包括基础数据类型和自定义数据类型。
				例：
					基础数据类型：
						typedef int HP;
						HP hp = 100;
					结构体类型：
					例1：
						struct MyPoint
						{
							int x,y;
						}
						typedef struct MyPoint MP;	// 重定义结构体类型时，也需要加上关键字。
						MP m = {100,200};			// 从定义后的结构体，在定义新变量时可以省掉struct关键字。
		结构体嵌套：
			结构体的成员变量也可以是别的结构体类型！
			【注意】结构体内部成员变量不得包含自己的类对象，但是可以有自己的类指针。
		结构体的大小和对齐：
			在定义结构体类型过程中，只是告诉程序该结构类型有哪些成员，这些成员并无具体内存和值。
			只有在定义了该类型变量时，成员才有具体的值，且占有内存。
			在VS中，计算结构体内存大小必须考虑内存对齐的情况，对齐是为了方便计算机读取数据
			【记忆】计算方式
				1、每个成员变量的其实位置必须是字节类型的整数倍，如果不是，则在前面补字节；
				2、所有成员变量分配完毕后，总的字节数必须是最大成员变量数据类型的整数倍，如果不是，则在后面补字节。
			【记忆】预处理命令：#pragma pack(num)
				这里num是一个正整数常量。在定义结构体之前加上该命令，这回改变结构体的对齐和大小计算规则：
				1、每个成员变量的起始位置必须是num的整数倍，如果不是，则在前面补字节
				2、所有成员变量分配完毕后，总的字节数必须是num的整数倍，如果不是，则在后面补字节。
				【思考】如果没有这个预处理命令，就相当与num默认是结构体内的最大成员变量数据类型的大小。
			【总结】在定义结构提示，按照递进或递减的顺序安排成员变量最优。
	联合体：	
		【记忆】特点：可以用相同的储存空间储存不同型号的数据类型，从而节省内存。
					可以理解为其成员变量是互斥存在，或者理解为该段内存由不同的解释方式。
					举例：
					1、互斥理解：游戏关卡过关条件，每一关都是不同类型的数值，可以用联合体。
					2、不同解释方式：通过位运算，在一个数据内存储不同的数据。
						比如在一个int里面存储RGB颜色数据:
						union COLOR{int color, char c[4]} cc = {0x123456};
						printf_s("%x\n%x\n%x\n%x\n", cc.color, cc.c[2], cc.c[1], cc.c[0]);	//123456	12	34	56	十进制
						printf_s("%d\n%d\n%d\n%d\n", cc.color, cc.c[2], cc.c[1], cc.c[0]);	//1193046	18	52	86	十六进制
						【记忆】%d是十进制整数占位符，将数据转换为十进制整数；%x是十六进制占位符，将数据转换为十六进制整数。
						【记忆】由于内存是先进后出，所以cc.c作为数组读取时，下标要从后往前。
		联合体类型定义：
			union 联合体类型名{成员列表};		// 定义后面要加分号
			union M
			{
				int a;
				char b;
				...
			};
		联合体变量定义和初始化（和结构体非常类似）：
			定义联合体象变量
			【注意】联合体变量初始化时，只能给第一个成员初始化。所以a应该是第一种数据类型，或者转换成第一种数据类型。
			1、定义联合体类型同时定义变量
				union 联合体类型名{成员列表} 变量名 = {a};
					union M
					{
						int a;
						char b;
						...
					} m = {1};
				union {成员列表} 变量名 = {a};	【注意】和结构体初始化类似，这里可用于单例模式。不推荐日常使用。
					union
					{
						int a;
						char b;
						...
					} m = {1};
			2、已定义联合体类型后，再定义变量
				联合体类型名 变量名 = {a};
				M m = {1};
			定义联合体指针变量
				联合体类型名* 指针名；
				M* p = &m;
		联合体变量的成员访问
			变量名.成员变量			m.a;
			变量名指针->成员变量		p->a;
		联合体的大小：
			因为联合体时不同数据类型共用一段内存，不存在同时存在多个成员数据。
			所以联合体的大小由最大成员变量的大小来决定。
	枚举：
		概念：也叫穷举。将变量的值一一列举出来，变量的取值只限于列举出来的取值范内。
		定义和初始化：
			【记忆】和结构体、联合体一样，枚举变量都有三种初始化方式。不初始化默认为0。
			定义类型：		enum 枚举类型名{成员列表（也叫元素列表）};
			定义变量：		枚举类型名 变量名;
			定义指针变量		枚举类型名* 指针名；
			
			enum 枚举名
			{
				标识符 = 整形常数,
				标识符 = 整形常数,
				标识符 = 整形常数,
				标识符 = 整形常数,
				...
				标识符 = 整形常数
			};
		【记忆】枚举如果没有进行初始化，即定义类型没有设定成员变量的值，则系统自动赋值0，1，2，3...。
				一旦有一个成员赋值后，其后面成员的值+1递增。
				枚举允许多个成员有相同的值。
			例子1：
				enum X{x1,x2,x3,x4} A;
				则x1,x2,x3,x4得值分别为0，1，2，3
			例子2：
				enum X{x1,x2,x3=0,x4} A;
				则x1,x2,x3,x4得值分别为0，0，0，1
			例子3：
				enum X{x1,x2,x3=10,x4,x5=-2,x6} A;
				则x1,x2,x3,x4,x5,x5得值分别为0，1，10，11，-2，-1
		【记忆】枚举的基础类型必须是整型，默认所有成员元素都是int类型。但是也可以改为short、long或者chart等其他整型，不能为浮点数类型。
			格式：enum 枚举类型名：其他整型类基础数据类型{成员列表};
			例子：
				enum X: chart
				{
					x1,
					x2,
					...
				};
		【记忆】访问修饰符为public或private。
			默认为public，表示该枚举类型在整个工程中都是可见的。
			private，表示该枚举类型只在所声明的模块中是可见的。
		【注意】
			1、枚举的每个元素用逗号隔开，不是用分号；
			2、元素初始化可以为负数，以后的标识符依旧+1；
			3、枚举变量只能取元素中的某个标识符常量；
			4、枚举允许多个成员有相同的值；
			5、任意两个枚举成员不能重名；
			6、枚举类型和基础数据类型不能隐式转换，但是可以强转；
			7、枚举值是常量而非变量，不能在程序中用赋值语句再对枚举元素赋值。
			8、枚举的成员元素可以看作一个常量来使用。
		枚举常用之处：
			比如表示星期。
			比如用来表示状态，可以和switch...case...搭配使用
类：
	概念：
		是具有相同属性和行为的对象的集合。也就是说是将某种对象概念抽象成对应的属性（数据）和行为（函数）。
		类是对象的抽象，对象是类的具体，是类类型定义的变量。
		类也属于自定义数据类型，可以看作结构体的升级版，是有函数的结构体。
	大小：
		空类的类对象也是占有一个字节的。
	类定义
		class 类名				// 类型需要是合法标识符，首字母一般大写
		{
		// 成员默认都是私有的
		
		// 访问权限修饰关键字		各个关键字的顺序是可以自己定义的，且可以重复
		public:		// 公有的	指本类和子类内外都能访问
		private:	// 私有		指仅仅本类里面能访问
		protected:	// 被保护	指本类和子类的里面能访问，类外不能访问
		}；						// 定义域后面要加分号
		例：
			class AA
			{
			public:
				int a;
			private:
				int b;
			public:
				void sa()	// 类里面可以定义或者声明成员函数
				{
					...
				}
			private:
				void ss();	// 声明的成员函数需要在类外定义
			}
			void AA::ss(){}	// 【注意】在类外定义类中声明的函数时，要加上作用域符标识，不然就只是定义一个普通全局函数。
		类对象定义和成员访问：
			格式：类名 对象名；
			例子：
				AA a;		// 定义类对象
				AA* p = &a;	// 定义类对象指针，必须初始化或赋值，不然调用会报错，因为没有具体的指向对象
				a.a;		// 对象访问成员变量	
				p->a;		// 对象指针访问成员变量
	【注意】class 和 struct区别
		class是只在c++中才有，作为类的关键字，在c中是不存在的。
		struct在c和c++都能声明定义一个结构体。但在c++中还可以声明定义类，拥有成员函数。
		【注意】虽然在c++中struct也能定义声明类，但是要求让struct定义结构体，class定义类。因为struct的成员默认公有，class默认私有。默认公有不符合对类的封装特性。
	类成员初始化和再赋值：
		类的私有成员是无法直接访问和初始话的，但是可以定义一个共有函数，在这个函数中对类的私有成员做初始化操作。
		以此推之，类成员变量的初始化和再赋值，就应该又专门的函数处理，而非直接访问赋值，以保证数据的安全。
		所以，也可以在类中专门定义一个用于初始化的函数。于是就有了构造和析构函数。
	构造函数和析构函数
		【注意】一个空类也是有三个默认函数的
			class MyClass
			{
				MyClass(){}						//默认的构造函数
				MyClass(const MyClass& obj){}	//默认的拷贝构造函数
				~MyClass(){}					//默认的析构函数
			}；	
		【注意】构造函数和析构函数都要写在public公有区，不然系统会调用不了。
		作用：用来完成对象数据的初始化和清理工作
		构造函数：
			概念：是一种特殊的成员函数。在类对象创建时会自动调用，为对象的成员变量赋初始值。
			特点：
				构造函数的函数名和类名相同
				构造函数没有返回值类型，也没有返回值
				构造函数可以重载，只要满足函数重载条件
				如果程序员没有写构造函数，系统会自动定义一个构造函数。
					1、系统给的构造函数其参数列表和函数体皆为空
					2、只要写了任何一个构造函数，哪怕只是声明，系统就不会给构造函数了
					3、如果写的构造函数全是带参数的，那么定义类对象时也必须都带参数，否则报错，因为找不到匹配无参数的构造函数
				【注意】如果类的成员函数定义在类里面，则默认为内联函数。所以在定义类时，请将普通成员函数定义在类外，类里面只做声明。
				例：
					class MyClass
					{
						int a;
						int b;
					public:
						MyClass()
						{
							a = b = 0;
						}
						MyClass(int e, int s)
						{
							a = e;
							b = s;
						}
					}
					MyClass obj_1;
					MyClass obj_2(10,20);				// 定义对象时，后面加括号和参数，则会调用有参数的构造函数
					MyClass* p1 = new MyClass();
					MyClass* p2 = new MyClass(3,4);		// 这里也是调用的带参数的构造函数
			成员初始化列表
				作用：构造函数实际上还是先定义成员变量，后赋值。针对需要定义时就需要初始化的成员函数，就要用到成员初始化列表。
				格式：在构造函数的参数列表后面加“:”，多个成员初始化赋值用“,”隔开
					例：
					class MyClass
					{
						const int a;
						const int b;
						const int c;
					public:
						MyClass(int i, int e):a(i),b(e),c(0)		// c因为没有对应的参数列表，所以可以随便写一个数据上去。
						{
						}
					}
					class MyBlass
					{
						const int a;
						const int b;
						const int c;
					public:
						MyBlass(int i, int e)；
					}
					MyBlass::MyBlass(int i, int e)	//【注意】初始化列表是加在定义构造函数的参数列表后面。声明构造函数时不要去加。
					:a(i),b(e),c(0)					//【注意】初始化列表是可以提行写的，方便阅读
					{
					}
		析构函数
			概念：是一种特殊的成员函数。在类对象生命周期结束时，系统可以自动调用，进行清理工作。主要用于释放内存的操作，也可以将所有想要在对象生命周期结束时做的操作都写进去。
			特点：
				析构函数的函数名和类名相同，再在前面加一个~。是唯一一个不是合法标识符的标识符。
				没有返回值和返回类型，也没有参数，所以任何类都只有一个析构函数，不可能重载。
				没有写的情况下系统会自动给一个函数体为空的默认析构函数。
				析构函数除了类对象的生命周期结束时系统自动调用，程序员还可以手动调用。不过这样做没有意义，一般很少见。
				【注意】不是调用了析构函数导致类对象生命周期结束，而是因为生命周期结束会自动调取析构函数。请注意里面的因果关系。
			【注意】栈区先构造的类对象后析构，符合栈内存的先进后出逻辑。
		拷贝构造函数
			概念：是一种特殊的构造函数。能通过拷贝构造函数完成一个复制的过程。
			特点：
				拷贝构造函数的第一个参数必须是当前类对象的引用。拷贝构造函数可以重载，只要第一个参数是当前类对象的引用，都算拷贝构造函数。
				先是构造函数，才可能是拷贝构造函数。
				如果没写，系统会自动给一个，将成员一一对应赋值。也可以自定义。
			调用时机：
				1、使用一个对象给另一个对象进行初始化
				2、使用一个对象构造另一个对象
				3、函数的参数是类的对象时
				4、函数的返回值是类的对象
				例：
				class MyClass
				{
				public:
					int id;
					int num;
				public:
					MyClass(){}
					MyClass(const MyClass& obj)
					{
						id = obj.id;
						num = obj.num;
					}
					MyClass(const MyClass& obj, int n)
					{
						id = obj.id;
						num = n;
					}	
					~MyClass(){}					
				}；
				MyClass obj_1;
				// 使用一个对象给另一个对象进行初始化
				MyClass obj_2(obj); 
				MyClass obj_3(obj, 10);
				// 使用一个对象构造另一个对象
				MyClass obj_4 = obj_2;
				// 函数的参数是类的对象时	【注意】这里是基于函数传参的本质是拷贝，将实参的值拷贝给形参
				void fun1(MyClass obj){}
				// 函数的返回值是类的对象
				MyClass fun2()
				{
					MyClass obj;
					return obj;		//【注意】调用fun2函数时，执行到这里obj其实会在函数结束时释放掉，返回的其实时obj的赋值体，所以会产生对象拷贝。
				}
				MyClass fun3()
				{
					return MyClass();	// 【注意】由于这里不是将函数内部的变量return出去，所以不会发生拷贝。MyClass()相当于处于函数fun3外面。这种写法成为匿名对象。
				}
			拷贝构造函数的重写的意义。
				实际应用中，类是会有指针类型的成员变量的。如果按照默认的拷贝构造函数，两个类对象的成员指针这回指向相同的地址，不符合实际应用需要。
				正确的做法是，让新对象的成员指针新开辟一个内存区，并将之前对象指针指向的内存区数据拷贝到新开辟的内存中来。
			深拷贝与浅拷贝
				浅拷贝：默认的拷贝构造函数执行的就是浅拷贝，将所有数据一一拷贝赋值
				深拷贝:根据实际情况，像类似的指针，要拷贝其代表的数据，而不是单纯拷贝指针指向的地址
			如何防止默认浅拷贝的发生
				现实应用中，有时候类在设计时是不考虑会发生拷贝的情况的，就没有写深拷贝的函数。但是在应用该类时有因为一些原因（比如迭代，比如多人协同出错等）出现了拷贝的情况，就会导致应该深拷贝时出现了默认浅拷贝。
				声明一个私有的拷贝构造函数，但是只声明不定义。这样当出现意料之外的拷贝时，系统会报错，方便维护。
	this指针：
		概念：
			系统自动生成，且隐藏的指针
			不属于对象的一部分，作用域在类内部
			类的普通函数访问类的普通成员时，this指针总是指向调用者对象
		作用：
			如果类的成员函数有参数的命名名和某类成员名字重名，且在该成员函数体中有需要用到该重名类成员，就应该用this指针来修饰该成员。
			反之，就没必要使用this指针。
		【记忆】this指针无法用于成员初始化列表，以及静态成员函数中，所以这些地方请注意命名去重。
		例：
			class MyClass
			{
			public:
				int num;
			public:
				void setNum(num)
				{
					this->num = num;	// 这里就必须用this指针区分同名的成员变量和成员函数参数
				}
				int getNum()
				{
					return num;			// 没有同名的情况就不需要写this指针了
					this->getNum();		// 不建议这样做，但是可以这样来写递归函数
					(*this).num;		// this指针解引用就是类对象，可以用.访问类成员
				}
				MyClass getThis()
				{
					return *this;		// 返回对象自己
				}
				MyClass getThisP()
				{
					return this;		// 返回对象指针
				}
			};		
	static 静态成员【难点】：
		在c++类中声明成员时，用static关键字修饰的成员，就是类的static成员，也叫静态成员。
		【注意】类的静态成员是可以在类没有创建任何对象时访问的。
		静态成员数据
			格式：static修饰的成员数据就是静态成员数据
			归属：静态成员数据不归属于类对象，而是归属于类。即所有类对象共享该静态成员数据内存。在计算类对象内存大小时不计入静态成员数据的内存大小。
			初始化：静态成员数据需要在类外初始化。
			访问方式：除了普通的类对象和类指针访问外，还有类作用域访问：类名::静态成员数据
		静态成员函数
			格式：static修饰的成员函数就是静态成员函数
			定义：在类中声明时带了static修饰时，定义就可以不用带。也可以将函数写成内联，字节在类中定义。
			访问方式：除普通的类对象和类指针访问外，还有类作用域访问：类名::静态成员函数
			特点【重点理解】:因为静态成员函数可以在没有生成任何类对象时调用和访问，所以函数内部不能访问和使用任何类的普通成员数据，也不能调用任何普通的成员函数，会因为还没有成员对象找不到报错。所以只能访问和使用类的静态成员函数。
			【注意】静态成员函数内部是没有this指针的，所以设置参数时注意不要和类的静态成员数据重名。
		例:
		class MyClass
		{
		public:
			int id;
			static int num;			// static修饰的成员数据为静态成员数据
			MyClass()
			{
				num++;
			}
			static setNum(int n)		// static修饰的成员函数为静态成员函数
			{
				num = n;				// 静态成员函数只能处理静态成员变量，不能使用普通成员数据，也不能调用普通成员函数
			}							// 【注意】静态成员函数没有this指针，所以设置参数时注意不要和类的静态成员数据重名。
		};
		int MyClass::num = 0;		// 静态成员数据只能在类外初始化，初始化时需要带上数据类型
		MyClass::setNum(10);		// 静态成员的访问想比普通成员，多了一个类作用域访问，而且都能在没有生成任何类对象时访问和使用。
		MyClass obj;
		obj.num;				
		(&obj)->num;
		MyClass::num;
		obj.setNum(10);				
		(&obj)->setNum(10);
		MyClass::setNum(10);
	const成员
		概念：在c++类中声明成员时，用const关键字修饰的成员，为常量成员
		常量成员数据
			声明类成员变量前加const
		常量成员函数
			声明类成员函数参数列表后加const
			【记忆】常量成员函数是不能对类对象的任何成员变量做数据修改的，也不能调用修改类对象成员变量的成员函数。其他则和普通成员函数一样。
			【记忆】常量成员函数可以修改类的静态成员变量。这是特例！因为静态成员变量归属与类，而不是类的对象。
		例:
		class MyClass
		{
		public:
			int id;
			const int m = 0;				// 【重点】语法上这样做常量成员数据的初始话没有问题，实际应用中会让所有类对象的这个该成员变量的值都相同且无法修改，没有实际的运用意义。
			const int num;					// const修饰的成员数据为常量成员数据
			MyClass(int n = 0):num(n)		// 常量成员数据必须用成员初始化列表，【注意】this指针只能用在成员函数里面，初始化列表无法使用。在this无法使用的地方注意命名去重
			{
			}
			~MyClass()
			{
			}
			getId(int n) const;				// 声明和定义常量成员函数时，都要修饰const关键字。关键字是函数的一部分
			getNum(int n) const				// const修饰的成员函数为常量成员函数，注意是修饰在参数列表后面的
			{
				return num;
			}
		};
		MyClass::getId(int n) const			// 在类外实现常量成员函数时，也要修饰const关键字。关键字是函数的一部分
		{
		}
		【记忆】如果在声明类对象时用const修饰时，则类对象就成了常量类对象，初始化后时不能修改任何的对象成员数据的。也因为类的静态成员不属于类对象，所以却可以修改类的静态成员变量。
		const MyClass obj（10）；			// obj这里就成了常量对象
		【记忆】常量对象只能调用常量成员函数，不能调用普通的成员函数。
	friend 友元【难点】：
		作用：
			类的特性之一是封装，友元是打破封装的手段。实际运用中请谨慎使用友元，减少代码的耦合性。
			类中被声明的友元函数和友元类可以访问类的所有（公有和私有）的函数和数据。
		格式：
			友元函数：
				在类中任意地方（不受public和private影响）声明：friend 函数头；
			友元类：
				在类中任意地方（不受public和private影响）声明：friend class 类名；
		特性：
			友元是单向的。类中声明的友元能访问自己的私有，不代表自己能访问友元的私有。
			不传递。友元的友元不是我的友元
			不继承。父类的友元关系不会继承给之类。
		友元函数
		友元类，友元类可以创建友元对象。
		例:
		class A
		{
			int num;
		public:
			A(){num = 0;}
			friend void func1(A obj);	// 友元函数声明方式，声明函数能访问本类中的所有成员
			friend class B;				// 友元类声明方式，声明类能访问本类中的所有成员
		};
		void func1(A obj)
		{
			obj.num = 10;
		}
		class B
		{
		public:
			void func1(A obj)
			{
				obj.num = 10;
			}
		};
	类的继承与派生：
		继承的概念：
			一种创建新类的方式，在原有类的基础上派生新的数据和函数，而不改变原有类，便于快速扩展功能。
			描述之前的类和新类的关系，基类与派生类（书面说法），或者父类和子类（篇口语化说法）。
		继承和派生：本质上两者是用不同角度描述的同一件事情同一个过程。
			继承是指在派生类角度上，继承了基类的数据和方法
			派生是指在基类角度上，派生出了新的类。
		继承的分类：
			单继承：派生类只有一个基类
			多继承：派生类有多个基类
		语法格式：
			class A{};
			class B{};
			class c:继承权限 A,继承权限 B		// 多继承用都好隔开，有多少写多少（无限）
			{
			};
		继承权限：
			公有继承	public
			私有继承	private
			保护继承	protected
			【注意】public、private和protected 写在类里是访问权限，在继承这里就是继承权限，需要区别开
			【注意】继承实际上是继承了基类所有成员的，只是继承权限会限制对成员的使用权限。
						公有继承	public		私有继承	private		保护继承	protected
			public			public				private				protected
			private			不可访问				不可访问				不可访问
			protected		protected			private				protected
			【注意】多级继承下的派生类的成员的访问权限要一级一级去查看继承情况得出。
			【注意】继承权限中用的最多的就是public继承
		派生类的构成
			因为系统会自动给到构造（包括拷贝构造）和析构函数，所以派生类会继承基类除了构造和析构函数之外所有的类成员。
			派生类是可以添加属于自己的成员的，这些成员父类无法访问。
			如果派生类中有成员命名和基类成员相同，基类的同名成员会隐藏，普通访问方式只能访问到派生类成员。基类的同名成员可通过添加“基类名::”的方式来访问
			如果派生类有多个基类，且多个基类之间有同名的成员，那这些成员也无法字节访问，需要通过添加“基类名::”的方式来访问
			例：
				class A
				{
				public:
					int num;
					int n;
					int s;
				}
				class B
				{
				public:
					int s;
				}
				class C:public A,public B	// 派生类继承基类用“:”开头，用“,”隔开，必须写继承权限
				{
				public:
					int num;
				}
				C pro;
				pro.n;			// 基类中普通成员可直接访问
				pro.num;		// 基类和派生类有同名成员时，基类的成员会隐藏，普通访问只能访问到派生类的对象
				pro.s;			// 因为有多个基类都有同名成员，所以无法区分报错
				pro.A::num;		// 基类和派生类，或者基类之间有同名成员时，需要添加“基类名::”方式来访问
				pro.A::s;		// 基类和派生类，或者基类之间有同名成员时，需要添加“基类名::”方式来访问
				pro.B::s;		// 基类和派生类，或者基类之间有同名成员时，需要添加“基类名::”方式来访问
		【重点记忆】基类和派生类的关系：
			因为一般而言，派生类是在基类基础上增加了成员的。
			所以基类对象不能给派生类对象赋值，这会导致派生类的一些成员无法初始化，就无法调用报错。但派生类对象可以给基类对象赋值。
			所以派生类指针指向基类对象，会导致派生类指针有多出的数据为空，无法调用报错。但是基类指针可以指向派生类对象。
			【总结】派生类对象也是基类对象，但是基类对象不是派生类对象。派生类对象可以当作基类对象使用。
		创建派生类对象时构造析构顺序
			基类构造-->派生类构造-->派生类析构-->基类析构		// 符合先构造的后析构原则
			在派生类可以通过成员初始化列表来调用基类给构造函数，以此实现多种现实需求：
				例：
				class Father
				{
				public:
					Father();
					Father(int n):num(n)
					{
					}
					~Father();
					const int num;	// const修饰的
				};
				class Son
				{
				public:
					Son();
					Son(int n, int v):Father(n), val(v)	// 通过成员初始化列表来调用基类给构造函数
					{
						Father(n);						// 【重点注意】这里如果这样写等同于创建一个没有名字的基类对象，传参为n。
					}
					~Son();
					int val;
				};
			【注意】派生类只需要注意调用自己直接基类的构造函数就可以了，基类的基类不需要额外操心。
		菱形继承：
			概念：类A派生出了类A1和类类A2两个不同的类，又有类AA同时继承了类A1和类A2。四个类构成一个菱形的继承图案。
			例：
			class A
			{
			public:
				int n;
			};
			class A1:public A
			{
			public:
				int a1;
			};
			class A2:public A
			{
			public:
				int a2;
			};
			class AA:public A1,public A2
			{
			public:
				int aa;
			};
			AA obj;
			obj.a1;		// 正常访问
			obj.a2;		// 正常访问
			obj.aa;		// 正常访问
			obj.n;		// 报错，有两个同名，无法识别
			obj.A1::n;	// 正常访问
			obj.A2::n;	// 正常访问
			问题：
				AA是类对象里面，会有两份来自类A的数据，但这两份数据之间一模一样，所以会浪费内存空间，且读取也不方便，必须用“类名::成员”的方式。多人编程时还必须协调好用哪一个不用哪一个。
			解决方式：虚拟继承
				关键字 virtual
				原理：A1和A2使用虚拟继承时，类中会多出一个四字节的虚拟指针。
					虚拟指针会标记所有继承下来的成员，如果在派生时发现有遇到相同虚拟指针，就会合并同类项，只派生一份数据。
					也可以理解为根据虚拟指针先继承基类A的一份数据，再继承A1和A2各有的数据。
			例：
			class A
			{
			public:
				int n;
			};
			class A1:virtual public A
			{
			public:
				int a1;
			};
			class A2:virtual public A
			{
			public:
				int a2;
			};
			class AA:public A1,public A2
			{
			public:
				int aa;
			};
			AA obj;
			obj.a1;		// 正常访问
			obj.a2;		// 正常访问
			obj.aa;		// 正常访问
			obj.n;		// 正常访问
	类的多态：
		联编：
			概念：指将程序中的标识符（变量名、函数名等）与实际存储地址或者实现代码关联起来的过程。
			静态联编：
				也叫早期联编，静态约束。指在编译时就确定了函数调用与具体函数实现的关联。
				适用于普通函数调用、重载函数调用和模板函数。
				执行效率高，不需要运行时查找。
				默认情况下c++使用静态联编，因为效率更高。
			动态联编：
				也叫晚期联编，动态约束。指在程序运行时才能确定函数调用与具体函数实现的关联。
				通过虚函数机制实现。
				是多态性的基础。
				需要运行时查找，效率相对不高。
			动态联编的好处：
				能编写更通用的代码
				实现接口与实现的分离
				支持更灵活的设计模式
			动态联编的实现条件：
				1、必须将动态联编的行为定义为类的虚函数。即需要一个类成员有虚函数的类。
				2、要有继承关系，且有虚函数的类要为基类。
				3、通过基类的指针或者引用，去调用派生类继承的虚函数成员函数。
		多态【难点】
			概念：在c++中，调用类的成员函数的时候，会根据调用当前函数所属的对象的类型的不同，可以去执行不同的函数。
				具体说就是调用一个对象的成员函数，会根据对象类型的不同，实际执行不同的代码。
				举例说就是，一只动物能跑，但是不同的动物跑的具体跑的动作不一样。动物是基类，人、马、牛、羊是派生类，跑是函数。
			虚函数和虚函数的特点：
				声明：用关键字virtual修饰的类成员函数，就是虚函数。
				格式：virtual 返回类型 函数名(形参列表);
					class A
					{
					public:
						virtual void func();	// 虚函数只需要声明时用virtual修饰即可
					};
					class B:public A
					{
					public:
						virtual void func();	// 作为派生类也是可以将重写的虚函数继续用virtual修饰成虚函数，这样自己的派生类就又能重写了。
					};
					class C:public B
					{
					public:
						void func();
					};
					void A::func(){}
					void B::func(){}
					void C::func(){}
				作用：在类族中实现多态的功能
				特点：
					虚函数列表和虚指针：
						虚函数列表和虚指针都是定义虚函数后，由系统自动给出。虚函数列表存储的是所有虚函数的首地址（函数指针），虚指针储存虚函数列表的首地址。
					函数重写：
						派生类在声明和基类函数同名的函数的时候，如果基类函数是虚函数，则可以视为派生类对基类虚函数的重新定义。这叫函数重写。
					虚函数列表和虚指针是不会被继承的。
				【记忆】虚函数的调用：相比普通成员函数调用，多了通过虚指针在虚函数列表中查找要调用的虚函数的过程。比普通成员函数的调用更消耗资源和时间。
				【记忆】构造函数一定不能为虚函数，因为对象的类型在构造时还没有建立虚函数列表。
				【记忆】析构函数推荐设置虚函数，为了防止派生类析构产生内存泄露。
			指针：用一个基类类型的指针，指向基类或者派生类的对象。通过这个指针调用重写的成员函数。就能实现不同的类对象调用的函数各有不同。
			例：
				class A
				{
				public:
					virtual ~A(){};			// 析构函数也应该是虚函数。
					virtual void func();
				};
				class B:public A
				{
				public:
					void func();
				};
				class C:public A
				{
				public:
					void func();
				};
				void A::func()
				{
					cout << "funcA" << endl;
				}
				void B::func()
				{
					cout << "funcB" << endl;
				}
				void C::func()
				{
					cout << "funcC" << endl;
				}
				A* p = new B();
				p->func(); 				// 输出“funcB”
				delete p;
				p = NULL;
				p = new C();
				p->func(); 				// 输出“funcC”
				delete p;
				p = NULL;
			【注意】如果基类A的func函数没有virtual修饰，则下面的函数调用都是输出“funcA”，即只能调用基类的成员函数，不能实现多态。
			【重点注意】程序多态还要将基类的析构函数也修饰成虚函数，不然在delete派生类对象时，只会调用基类的析构函数，派生类的析构不会调用，就会导致内存释放遗漏，内存泄露。
					非多态情况下，是调取指针类型的类成员函数；多态情况下，是调取指针指向对象类型的类成员函数。这是实现多态的基本原理。
					同理，如果不将基类的析构函数也设置为虚函数，释放对象时就只会调取基类的析构函数，那么属于派生类特有的内存就无法释放，会造成内存泄露。
					反之，将基类析构函数也设置为虚函数，释放对象时就会调取派生类的析构函数，而调取派生类析构函数时也会调用基类析构。就避免了释放不完全可能会导致的问题。
		纯虚函数【难点】
			概念：没有函数体的虚函数。即在虚函数声明时，函数头等于0，并不再定义该虚函数。
				【注意】析构函数也可以写成纯虚函数。
			格式：virtual 返回类型 函数名() = 0;
				class A
				{
				public:
					virtual ~A() = 0;			// 析构函数的纯虚函数，内外还是要再定义一次。
					virtual void func() = 0;	// 析构函数之外的其他纯虚函数只做声明，后续不再定义虚函数。
				};
				A::~A(){}						// 析构函数的纯虚函数依然要在内外定义。
			作用：作为基类不做函数体的实现，纯粹由自己的派生类做函数的具体实现。
			抽象类：
				概念：类中只要出现了纯虚函数，那这个类就是抽象类。无论这个纯虚函数是继承得来还是自己拥有。
				特点：
					抽象类不能用来定义对象，但是可以用来定义指针。抽象类因为没有自己的类对象，所以指针只能用来指向自己的派生类，为多态服务。
					因为纯虚函数可以被继承，所以只要抽象类的派生类，没有将基类的所有纯虚函数实例化，那么该派生类也是抽象类。
			虚基类：派生类在继承基类时有加上virtual关键字修饰，则该基类就是虚基类。（请参照菱形继承部分）			
		final：是c++11引入的关键字，主要用于限制类的继承和虚函数的重写。
			意义：提高了编程安全性，也降低了灵活性。请程序员结合实际情况谨慎使用。
			修饰类：被修饰的类不能再被继承。已经继承该类的代码会报错需要修改。
				格式：class 类名 final{};
				应用场景：
					设计不被希望扩展的类（如某些工具类、单例类等）
					多人编程，防止自己写的类被意外继承
					有些编辑器可能会因为确定该类不被继承，性能上会有优化。
			修饰虚函数：被修饰的虚函数在派生类中不能被重写。已有的重写代码[可能]会报错需要修改。
				【注意】c++中，final修饰虚函数只是禁止被重写，还是允许派生类存在和该虚函数同名的函数的。但是有些编辑器如MSVC会更加严格，即禁止重写，也禁止重名。
					如果遇到项目在MSVC中打开出现报错，要么关闭掉编辑器的严格检查（不推荐），要么不定义同名函数或者修改掉报错的函数名。
				格式：
					virtual 返回类型 函数名() final;
				应用场景:
					设计不希望被修改的关键虚函数
					确保某些接口行为保持不变
					防止派生类意外改变基类的重要行为
			【注意】final不是c++的保留关键字，只是在修饰虚函数和类时为关键字，其他地方可以作为标识符使用。但是非常不建议！
			修饰纯虚函数：不要则么做，如果有现实逻辑需求，应该用其他方法实现。
				格式：virtual 返回类型 函数名() final = 0;
				语法允许：纯虚函数可以被声明为final，但是极少这样做。且想VS这类严格检查的编辑器是不允许这样做的。
				语义矛盾：纯虚函数本意是强制派生类实现，而 final 禁止派生类重写，二者看似冲突。
				实际用途：用于 中间类（中间基类），表示 "必须实现，但实现后不能再被覆盖"。
					即唯一合理场景：设计一个抽象基类，要求派生类必须实现某个接口，但禁止进一步重写。
					通常用于框架设计，确保关键接口的最终实现不被修改。
	运算符重载：
		概念：在类中定义一个新的函数来重新赋予运算符新的运算规则。本质上是函数的重载。
		格式：
			普通函数的格式：	返回类型 函数名(形参列表){}				// 函数体可以在类中定义，或者在内外定义
			运算符重载格式：	返回类型 operator运算符名称(形参列表){}		// operator运算符名称 就是运算符重载的 函数名   operator是
		例：
			class AA
			{
			public:
				AA(){};
				AA(int nn, int mm):n(nn), m(mm){}
				~AA(){};
				void display()const;
				AA operator+(const AA& obj) const;		// 关键代码
				friend AA operator+(const AA& obj, const int n);	// 【重点注意】需要将全局的运算符重载函数标记为友元，不然可能无法访问私有数据
			private:
				int n;
				int m;
			};
			void AA::display()const
			{
				cout << n << "+" << m << endl;
			}
			AA AA::operator+(const AA& obj)const		// 关键代码
			{
				return AA(this->n + obj.n, this->m + obj.m);
			}
			AA operator+(const AA& obj, const int n)	// 【重点注意】运算符重载并不一定在类中，也可以写成全局函数。
			{
				return AA(obj.n + n, obj.m);
			}
			AA obj1(1,2);
			obj1.display();
			AA obj2(7,3);
			obj2.display();
			AA obj3 = obj1 + obj2;
			// AA obj3 = obj2 + obj1;				// 【注意】加法和乘法运算具有交换性，即左右两边交换不影响结果。但减法和除法左右两边交换结果不一样。
			// AA obj3 = obj1.operator+(obj2);		// 【注意】使用运算符重载也能写成函数调用方式，这里等同于obj1 + obj2
			// AA obj3 = obj2.operator+(obj1);		// 【注意】运算符是有结合性的，一般双目运算符为左结合性，即左边为对象，右边为参数。所以这里等同于obj2 + obj1
			obj3.display();
			obj3 = obj1 + 5;						// 【注意】在调用全局的运算符重载函数时，相当于将运算符前后数据作为参数了，要注意参数顺序。这里就不能随意交换位置了。
			obj3.display();
			obj3 = obj1 + 7；						// 【注意】类中一般默认带有一个赋值运算符的重载函数的。除了初始化用赋值运算符调用的是拷贝构造外，其他情况都是调用的赋值运算符重载函数（赋值函数）。
			obj3.display();
		规则详解：
			1、并非所有的运算符都可以重载：三目运算符，sizeof运算符，成员运算符“.”等
				【注意】自增自减运算符也能重载，为了区分前后置，需要用到占位参。
			2、重载不能改变运算符的优先级
			3、重载不会改变运算符的用法，即不会改变运算符的结合性和目数
				【注意】语法上可以将加法运算符重载为减法，但是禁止这样做。
			4、运算符重载函数不能有默认的参数。相当于改变了运算符的目数。
			5、运算符可以作为类的成员函数，也可以作为全局函数。
				【注意】作为全局函数，是多少目运算符就需要有多少个参数。作为类成员函数，因为默认有this指针，可以少一个参数。
			6、箭头运算符->下标运算符[]赋值运算符=函数调用运算符()，这是个只能以成员函数的形式重载。
		重载>>和<<
			建议作为友元函数重载。
			cin和cout在c++中其实是两个类对象。所以对应的重载函数的返回类型分别是istream类和ostream类
			例：
			class A
			{
			public:
				A(){};
				~A(){};
			private:
				int a_m;
				int a_n;
			friend istream& operator>>(istream& in, AA& obj)；	// 涉及到访问私有成员，一定要声明友元
			friend ostream& operator<<(ostream& out, AA& obj)；
			};
			istream& operator>>(istream& in, AA& obj)
			{
				in >> obj.n >> obj.m;
				return in;										// 一定要有返回，才能连续输入或输出
			}
			ostream& operator<<(ostream& out, AA& obj)
			{
				out << "(" << obj.n << "+" << obj.m << ")";
				return out;
			}
			调用：
			A obj;
			cin>>obj;				//operator>>(cin,obj); 函数调用模式写，作用完全等同
			cout<<obj<<endl;
			operator<<(cout,obj);
			A obj1;
			cin>>obj>>obj1;				//operator>>(operator>>(cin,obj),obj1);		有返回值的函数可以作为其他函数的实参。
			cout<<obj<<obj1;			//operator<<(operator<<(cout,obj),obj1); 	注意函数调用方式的代码执行顺序。
		注意事项：
			1、语法简单，重点是运算符的规则要掌握
			2、运算符重载后可以显示调用，也可以隐式调用。不过一般都隐式调用
				显示调用即前文的函数调用方式
				隐式调用即运算符调用
			3、注意和友元联合使用。
				友元虽然破坏封装，但是注意不要在友元函数中修改数据，可以加上const修饰。
			4、类中系统会自动给到一个赋值运算符重载函数（赋值函数）。但是有类似拷贝函数的浅拷贝和深拷贝的情况。
				所以如果类中有指针类数据，需要根据实际情况，判断如何重定义赋值运函数。
	模板：
		定义模板关键字：template
		声明类型关键字：typename/class		【记忆】都是用于模板列表中做类型声明。前者多用于模板函数，后者多用于模板类。语法上都是随便用的。
		概念：
			1、模板与泛型编程：
				泛型编程：指编写和类型没无关的逻辑代码。
				模板：实现代码重用的一种编程方法。可以将类型参数化。也是泛型编程的前提条件。
			2、模板的分类：模板其实是一个东西，根据作用对象不同而有所区分
				函数模板：模板作用于函数，就是函数模板。通过函数模板方式定义的函数为模板函数
				类模板：模板作用于类，就是类模板。通过类模板方式定义的类叫模板类
			3、格式：template<模板列表> 函数/类
				【注意】c++中的模板列表用尖括号“<>”修饰。作用是将类型作为参数。
				【注意】在函数模板定义中，模板列表里面也可以是函数形参，用于定义非类型模板参数。
		函数模板【难点】
			关键规则：
				模板声明与定义通常需在头文件中（除非使用 export，但多数编译器不支持）。
				模板实例化：编译器在调用时生成具体代码（隐式实例化）。
				分离编译问题：模板定义对编译器必须可见，否则导致链接错误。
			1、通过函数模板定义模板函数语法：
					template <模板列表> 函数返回值类型 函数名(形参列表){函数体;}
						模板列表：typename T1,typename T2,...,typename Tn	多个类型参数用逗号“,”隔开，每个类型前面用typename修饰。(也可以用class，只是约定俗成用class修饰模板类)
						形参列表和函数体：里面的数据就可以用模板列表的数据类型
				普通函数模板：	template <typename T> void func(T param)				通用格式
				特化				template <> void func<int>(int param)					针对特定类型的优化实现
				类成员函数模板：	template <typename U> void Class<T>::insert(U value)	增强类的灵活性
				非类型模板参数	template <int N> void fillArray(int (&arr)[N])			编译期已知大小的数组操作
				变参模板			template <typename... Args> void log(Args... args)		可变参数函数	(C++17)
				模板约束			template <std::integral T> T square(T x)				类型安全约束 	(C++20)
			2、调用模板函数：
				【注意】模板函数的类型是调用函数时，将类型作为参数传入函数的。
				函数名<模板列表>(参数列表);
				隐式调用：调用时，模板列表是可以隐藏的，系统会根据函数参数自动推导。但是如果推导不出来就会报错，就需要改成显示调用。
				显式调用：调用时，不隐藏模板列表。推荐调用模板函数时都写成显示调用。
					【记忆】显示调用时，如果参数类型不对，模板列表会将参数转换成指定类型传入。且可以根据需要用const修饰模板列表。
			3、模板函数的重载。
				模板函数和普通函数都能重载，且如果模板函数和普通函数同名，也互相构成重载。
				【注意】模板函数隐式调用时，如果参数和重载的普通函数一样，系统会优先匹配重载的普通函数。
			例：
			class MyData
			{
			public:
				MyData(int n = 0) :num(n) {}
				int num;
			};
			template <typename T> void func(T& a, T& b)
			{
				cout << a << " == " << b << " is " << (a == b ? "true" : "false") << endl;
			}
			template <> void func<MyData>(MyData& a, MyData& b)
			{
				cout << a.num << " == " << b.num << " is " << (a.num == b.num ? "true" : "false") << endl;
			}
			【注意】一般而言，将上面的重载函数替换成下面的运算符重载函数更好，更具有扩展性。
				bool operator==(MyData a, MyData b)
				{
					return a.num == b.num;
				}
				ostream& operator<<(ostream& out, MyData& obj)
				{
					out << obj.num;
					return out;
				}
			MyData a(10);
			MyData b(10);
			double aa = 10.0;
			double bb = 10.1;
			func(a, b);
			func(aa, bb);
			func(10, 20);		// 【注意】报错！因为int类型常量不是int&类型。
		类模板【难点】
			通过类模板方式定义模板类语法：template <模板列表> class 模板类名{类成员;};
				模板列表：class T1,class T2,...,class Tn多个类型参数用逗号“,”隔开，每个类型前面用class修饰。(也可以用typename，只是约定俗成用class修饰模板类)
				类成员：类成员就可以声明为模板列表里面的数据类型。
			基础类模板	template <class T> class Box {...}														通用类型容器
			成员函数定义	template <class T> void Stack<T>::push(...)												分离编译
			全特化		template <> class Box<bool> {...}														针对特定类型优化
			偏特化		template <class T> class Pair<T,T> {...}												部分条件定制
			嵌套模板		template <class Outer> class OuterClass { template <class Inner> class InnerClass; }	复杂数据结构
			变参模板类	template <class... Args> class Tuple {...}												可变参数结构（如元组）
			模板别名		template <class T> using Vec = std::vector<T, MyAllocator<T>>;							简化复杂模板名
			约束模板		template <std::integral T> class IntegerContainer {...}									类型安全约束（C++20）
			【注意】模板列表也支持非类型模板参数（如 template <int N>）
			【记忆】模板类是不能直接创建的，创建对象时要给出模板参数。
				例：
				//template <class T1 = int, class T2 = double>		// 【注意】类模板的模板列表也可以设置默认值，且默认值是从后往前给，但一般不会给默认值
				template <class T1, class T2>
				class MyData
				{
				public:
					MyData(T1 n = 0, T2 v = 0.0): num(n), val(v){}
					// 定义内联函数
					void setNum(T1 n){num = n;}
					T1 getNum(){return num;}
					// 声明成员函数
					void showData();
				private:
					T1 num;
					T2 value;
				}
				// 模板类成员函数定义  template <模板列表> 函数返回类型 模板类名<模板参数>::函数名(形参列表){函数体;}; 
				template <class T1, class T2>
				void MyData<T1, T2>::showData()					// 【提示】这里可以换行写，也可以一行写
				{
					cout << num << " and " << value << endl;
				}
				// 定义模板类对象。
				// MyData<> obj1(3,3.14);			//【注意】如果模板有设定默认类型，就可以省略模板参数，但是尖括号必须保留，这是语法规定。另外如果初始化参数类型和默认模板不一致也会报错！
				My_Data<int, double> obj1(3, 3.14);
				// 模板类对象成员函数调用（和普通成员函数调用没有区别）
				obj1.showData();
				My_Data<char, double> obj2(70, 3.14);
				obj2.showData();
			类模板作为函数的参数：
				例：
				void tes_Fun1(MyData<int,double>& obj){obj.showData();} 	// 指定了模板类型
				test_Fun1(obj1);
				template <typename T1, typename T2> void tes_Fun2(MyData<T1,T2>& obj){obj.showData();}	// 将函数也定义为模板
				test_Fun2(obj2);
				template <class T> void tes_Fun3(T& obj){obj.showData();}	// 将函数也定义为模板,但是是将整个类作为模板传参，本质上是将MyData<T1,T2>封装成模板T
				test_Fun3(obj2);			// 也可以有另一种写法：test_Fun3<MyData<char, double>>(obj1);  
			类模板和继承：
				格式：class 派生类名 :继承权限 基类名<模板参数>
				【记忆】继承类模板时需要给出具体模板参数
				例：		
				template <class F_T>
				class F_A
				{
				public:
					F_T _f_num;
				};
				// 派生类不是模板
				class S_A :public F_A<int>
				{
				public:
					int _s_num;
				};
				// 生成对象
					S_A obj_A();
				// 派生类是模板
				template<class S_T1, class S_T2> class S_B :public F_A<S_T1>
				{
				public:
					S_T1 _s_num;
					S_T2 _s_val;
				};
				// 生成对象
					S_B<int, char> obj_B();
			注意事项：
				C++类模板必须全定义在头文件中：
					在C++中，普通类的定义通常放在头文件（.h）中，而成员函数的实现可以分离到源文件（.cpp）中，通过包含头文件完成编译链接。
					然而，类模板的定义和所有成员函数实现必须完整地放在同一个头文件中。
					这种区别的根本原因在于C++的编译模型和模板实例化机制：普通类的成员函数在编译时可以直接通过链接器找到定义，而模板是“代码生成蓝图”，
					编译器需要在每次实例化具体类型（如MyTemplate<int>）时看到完整的模板定义，才能生成对应类型的实际代码。若将模板成员函数分离到.cpp文件，
					其他文件使用不同模板参数时会导致链接错误，因为编译器无法跨编译单元推导模板实例化。因此，类模板必须遵循“定义与实现完全可见”的规则，
					确保编译器在调用处能即时生成特化代码。
				.hpp文件：
					概念：
						.hpp是C++社区为清晰区分C/C++代码、明确模板定义可见性而采用的约定，功能上与.h无本质差异，但能显著提升代码可读性和工程规范性。
						.hpp和.h在功能上完全相同，均用于存放类声明、模板定义、内联函数、常量等。
							.h是传统C头文件，或C/C++通用头文件。
							.hpp则明确表示该头文件专为C++设计，可能包含模板、命名空间等C++特有语法。
					作用：
						避免C和C++头文件混用：明确就是C++头文件
						模板支持：C++模板的定义必须完整可见（不能分离声明与实现），.hpp文件通常直接包含实现。
					代码组织清晰：
						实际项目中，有些会要求.h专用于C兼容头文件（extern "C"），.hpp为C++专属头文件（含类、模板、RAII等），不兼容C。
					注意事项
						编译器无关性：.hpp只是约定，编译器不强制区分。
						模板必须放在.hpp：因模板实例化需编译时可见（这是硬性要求）。
						一致性：项目内应统一约定，避免混用.h和.hpp造成混淆。
		模板与友元
			1、类模板友元内联函数
				将友元函数的定义直接写在类模板里面。
				格式：friend 返回类型 函数名(类名<模板参数>& obj){函数体;}
				例：
				template <class T> class M
				{
				public:
					M(T t = 0) :m_a(t) {}
				private:
					T m_a;
					friend void show1(M<T>& obj)
					{
						cout << obj.m_a << endl;
					}
				};
				M<int> obj(20);
				show1(obj);
			2、类模板友元普通函数
				格式：
					类前函数声明：template <模板列表> 返回值类型 函数名(类名<模板列表>& obj)；
					类中友元声明：template <模板列表> 返回值类型 函数名<>(类名<模板列表>& obj)；
					类后函数定义：template <模板列表> 返回值类型 函数名<>(类名<模板列表>& obj){函数体;}
				例：
				1	template <class T>class M;						// 第一步必须在最前面声明类
				2	template <class T> void show2(M<T>& obj);		// 第二步必须在类声明和定义中间声明友元函数
				3	template <class T> class M						// 第三步定义模板类，且在类中对友元函数做友元声明		
					{
					public:
						M(T t = 0) :m_a(t) {}
					private:
						T m_a;
						friend void show2<>(M<T>& obj);				// 友元声明
					};
				4	template <class T> void show2<>(M<T>& obj)		// 第四步定义友元函数
					{
						cout << obj.m_a << endl;
					}
					M<int> obj(20);
					show2(obj);
				总结：
					尽可能不在类模板中使用友元函数，或者在类中定义友元函数。
	
string类
	string是c++中的字符串类，类似于c中的字符数组。
	在c和c++语言中，为了调用string的库函数，都需要加载库函数头文件：#include <string.h>
	而c++中要使用string类，需要加载库函数头文件：#include <string>
	【注意】c++中#include <string.h>和#include <string>是加载的两个不同的文件。前者是兼容的c语言的string库函数，后者是使用c++的string类。
	【注意】string类在std命名空间内，调用还需要声明命名空间，或者加std::
	string类对象的定义
		string str;					// 类对象的定义
		string str1 = "567bcd";		// 类对象的定义和初始化
		str = "123456abc";			// 类对象的赋值
	string类常用函数
		int len = str.length();		// 返回字符串长度
		char ch = str[3];			// 返回字符串对应下标的字符
		char ch = str.at(3);		// 返回字符串对应下标的字符
		str.clear();				// 清空字符串
		bool emp = str.empty();		// 判断字符串是否为空，为空返回true,反之返回false
		bool emp = (str == str1);	// 比较两个字符串是否相等，如果相等返回true,反之返回false
		
	
指针和地址：
	地址：
		概念：计算机最基本的存储单元为字节，而每个字节都有其对应的编号，其编号就是该字节的地址。
			 地址时一个十六进制数。32位系统下为int类型整数，64位系统下为long类型整数。
		结果为地址的表达式：
			指针变量			int *p	int **p							p
			数组名			int s[5]	char s[5]	char *s[5]		s
			函数				void f(){};								f
			字符串字面常量	"123456"
			变量取地址		int a	int *a	char a[5]				&a
		地址进行的运算以及结果类型：
			地址[整数]		*（地址+整数）					变量（包括指针）	//建议使用 *（地址+整数）写法，以便区分指针和数组
			*地址			等同于地址[0]					变量（包括指针）
			地址+整数		地址+整数*sizeof(地址类型) 		地址				//这种计算叫地址偏移
			地址-地址		编号之差/sizeof(地址类型) 		整数（有符号数）
			【注意】没有地址+地址的这种算法，报错
	指针：
		概念：指针是一种专门用于存放内存地址的特殊变量，指针类型就是该地址所存放的变量的数据类型。可以通过指针访问该地址存放的数据。
			  多了一种访问数据的方式。
		定义：类型名 *标识符；
			int *p = NULL;
		【记忆】野指针
			int *p;
			由于p没有被赋值，即没有被初始化指向，则会被自动指向编号为0x00000000的地方。
			此时p被成为野指针，是不能进行赋值以外的任何操作的，不然会报错。
			如果p确实没有指向，可通过p=0或p=NULL主动指向0地址，防止误用指针。
		【注意】同时定义变量和指针时，定义的到底是变量还是指针
			int a, b;		变量，变量
			int a, *b;		变量，指针
			int *a, b;		指针，变量
			int* a, b;		指针，变量	【强调】这一行和上一行本质一样，只是写法区别，不建议这样写，但要认识
			int *a, *b;		指针，指针
		&和*符号
			&	取地址符号。&变量a，返回变量a的首地址。
				【注意】这里的变量a既可以是普通变量，也可以是指针或者其他返回值为变量的表达式。
			*	解引用符号。*指针p，返回指针p所指向的变量。
				【注意】这里的指针p既可以是普通指针，也可以是返回值为指针的表达式。
			【区分】&不同使用方式，代表的意思不一样
				&表示引用时，一定是在定义语句中：
					int a;
					int &ra = a;
				&表示取地址时，一定不是在定义语句中：
					int a;
					int *p = &a;	// 赋值语句
			【区分】*不同使用方式，代表的意思不一样
				*表示指针时，一定是在定义语句中：
					int a;
					int *p = &a;
				*表示解引用时，一定不是在定义语句中：
					int a = *p;		// 赋值语句
		【记忆】引用和指针的区别：
			指针时存储地址的特殊变量，引用只是变量的别名。
			引用必须初始化，但指针可以不用初始化（野指针）。
			存在指向空值的指针，但不存在空值的引用。
		【记忆】表达式是char类型地址，且输出结果是字符串的几种情况：
			char a;
			cout<<&a;
			
			char b[5];		【注意】b是字符串数组，本质是在栈内存中开辟数组并初始化，因为是数组名，不能做自增自减运算。但是b[0]能。
			cout<<b;		【注意】如果b定义在函数形参里面，则可以看作char *b。因为函数形参的数组名，传参实际是传的数组首地址。
				
			char *p="123";	【注意】p是指向常量内存区字符串字面常量的指针。p能做自增自减运算，但是p[0]不能。
			cout<<p;
			
			char **m[5];
			cout<<*m;
			cout<<m[0];
			
			cout<<"aaa";  
			
			cout<<(char*)任何表达式
		【记忆】常量指针和指针常量
			常量指针是指针，是指向常量的指针。可以改变指针指向，但是不能改变所指变量的值。
				const int *p;
				int const *p;
			指针常量是常量，指针本身是常量。可以改变所指变量的值，但是不可更改指针指向，且必须初始化。
				int* const p;
		【记忆】const在c和c++的区别：
			在c中，const修饰变量后，给变量增加了一个只读的属性，变量还是变量。
			在c++中，const修饰变量后，是直接将变量的性质修改成为了常量。
		【记忆】数组指针和指针数组
			数组指针是指针，是指向数组的指针。
			数组名怎么用，数组指针就怎用
				指向一个数组，数组需要为二维及以上。
				定义格式： 	数据类型 (*指针变量名)[第二维数列大小]；
				int arr[2][3]={1,2,3,4,5,6};
				int (*p)[3] = NULL;		// 数组指针，可以指向所有列为3的int类型二维数组。
				p = arr;	//二维数组的首地址赋值给可以指向所有列为3的二维数组的数组指针。
				int *q = &arr[0][0];		// 普通指针这样写才是合理的。
				int (*t)[2][3] = NULL;		// 也是数组指针，指向所有2行3列的三维数组。
			【注意】数组指针+整数，是整行加的
				int (*p1)[3] = p + 1;  //p1 所指向的地址是arr[1]的首地址
			【记忆】类型从定义：定义一个数组指针的类型：
				typedef int(*PARR)[3];	//	定义一个数组指针类型，通过类型给出的变量，为可以指向列为3的二维数组的指针
				PAEE p2 = arr;
			指针数组是数组，数组所有成员是指针的数组。
				int *arr[5];
		【记忆】函数指针和指针函数
			函数指针：是一个指向函数的指针。函数也是有地址的，函数名即函数地址。
				定义格式：	返回类型 (*函数指针变量名)(形参列表)；
					int (*pFun)(int, int) = NULL;	//	指向所有返回值为int类型，且有两个int类型形参的函数。
					int (*pFun)(int a, int b) = NULL;		// 还可以写成这样
					例：
						int fun_add(int, int);	// 函数声明		可以理解为在声明函数时，就定义了一个变量，这个变量就是函数的地址
						pFun = fun_add;
						int fun_add(int a, int b){return a+b;}	// 函数的定义可以理解为将函数定义的内容返回到声明的地址里，这样实现了函数的调用。
				用处：
					多数用在回调函数上：即将一个函数地址作为参数，传递给另一个函数上。函数指针作为函数参数。
					例：
						int mAdd(int,int);
						int mSub(int,int);
						int fun(int a, int b, int (*myOp)(int, int))	// 这里myOp就为回调函数
						{
							return myOp(a,b);
						}
						
						fun(3,2,mAdd);		//结果为5
						fun(3,2,mSub);		//结果为1
						
						int mAdd(int a,int b){a+b;}
						int mSub(int a,int b){a-b;}
				函数指针的从定义：
					typedef int(*PFUN)(int, int);	//函数指针类型重定义，可以用类型定义变量			
			指针函数：指函数的返回类型是指针类型的函数。
		【重要】指针与动态内存分配
				指针相比于变量，无非就是多了一种数据访问形式。正常情况下，能用变量访问数据，就不要用指针访问。
				但就有写时候，有些数据是没有变量名的，那就只能用指针去访问和管理数据了。这是指针的重要用处。
			动态内存分配：程序员根据需求，向系统申请所需大小的内存空间。因为动态内存都是在堆区开辟，也叫“开堆”。
				例：
					int *p = NULL;
					p = (int*)malloc(sizeof(int));	//	分配一个4字节大小的内存区域，将首地址当成(int*)赋值给p。
					*p = 123;						//	通过解引用的方式对分配的内存大小赋值。p相当于指向一个没有名字的int变量，不需要变量名的参与。
				本例中展示的就是指针最常用的用法。
			头文件和关键字
				头文件：stdlib.h
				【注意】这四个属于C语言的库函数，不是关键字。因为是函数，所以调用时要加括号传参。
					malloc
					calloc
					relloc
					free
				malloc
					作用：分配一个大小为size的内存区域，返回一个void类型指针
					格式：malloc(size);
					例：p = (int*)malloc(sizeof(int));		分配一个4字节大小的内存区域，将首地址转成int*类型赋值给p。p相当于指向一个没有名字的int变量
				calloc
					作用：分配n个大小为size的连续内存区域(可以参考数组加强理解)，返回一个void类型指针
					格式：calloc(n,size);
					例：p = (int*)calloc(4,sizeof(int));		分配4个4字节大小的连续内存区域，将首地址转成int*赋值给p。p相当于指向一个没有名字的int[4]数组
				relloc		
					作用：重新分配通过malloc或calloc开辟的内存空间，改变其内存空间大小。
					格式：relloc(p,size * n);	给p重新分配n个大小为size的连续内存区域。并不会修改p原指向的地址和存储的值。多用于数据扩容。
					例：	relloc(p,sizeof(int) * 10);	
						relloc(p,40);
				【注意】以上三个函数都是返回void类型指针。如果需要确定类型，需要强转。
					例：
						char *p = (char*)malloc(sizeof(int));
						char *p = (int*)calloc(4,sizeof(char));
				【注意】malloc(size * n) 其实等同于 calloc(n,size);  所以很多开辟动态内存的时候，都用malloc，用的少。
				free
					作用：用于释放malloc、calloc或relloc开辟的动态内存空间
					格式：free(标识符);
				【记忆】动态内存分配的内存在堆区。堆区的内存由程序员主动分配，也该由程序员主动释放。
					   一定要记住，凡是手动开辟的内存空间，使用完后一定要手动释放，否则就会发生内存泄露。因为电脑内存有限，内存占满后程序就会运行崩溃。
				new		开辟内存，类似于malloc，都是在堆中开辟内存，返回的是申请的内存空间的首地址
					1、申请单个内存
						int* p1 = new int;
						*p1 = 10;
					2、申请单个内存且初始化
						int* p2 = new int(10);
					3、批量申请（连续的内存）		// 无法初始化，但可以后续循环赋值
						int* p3 = new int[10];
						int* p4 = &p3[3];
				delete	释放内存，类似于free
					delete 标识符	是指释放标识符所指向地址的内存
					delete[] 标识符	是指将标识符所指向地址开始，往后直到[]标记的地址全部释放。
					1、释放单个内存
						delete p1;
						delete p2;
					2、释放多个连续内存
						delete[] p3;
						delete[] p4;	// 【注意】这里p4指向的不是之前开辟的首地址，则会释放不完全。因为释放是从p4开始往后的
				【注意】new和delete都是c++才有的关键字，也是内置运算符，要成对出现，不然有内存泄露的风险。因为不是运算符，就不需要使括号传参。
		指针和结构体：
			例：struct Stu
				{
					int id;
					char *name = (char*)malloc(sizeof(char)*64)；
				} m；
			结构体内部成员变量为指针：
				上面例子中，m.name就为指针成员变量。m.name，32位的x86系统下位4字节，64系统为8字节。
				【注意】m以及其成员变量都开辟在栈内存中，但是m.name里面却存储一个指向堆内存的地址。实际通过堆内存存储数据。
				【注意】char*类型不能直接赋值字符串字面常量，但是可以循环赋值，胡总和strcpy赋值。
			结构体指针：指向结构体变量的指针
				Stu *p = &m;
				p->id = 100;
				strcpy(p->name,"lisi");
				指针访问成员变量，用->符号。包括联合体和枚举，类等类型。
		多级指针：
			概述：指向指针的指针，即为多级指针。指向普通变量的指针，即为普通指针，也叫一级指针。
				例：	int a = 10;
					int *p = &a;
					int **q = &p;		这里q就是一个多级指针，也叫二级指针
					int ***t = &q;		三级指针，以此类推。

文件操作：
	头文件：#include <stdio.h>
	文件的定义和分类：
		程序文件：用于编写代码的文件。C语言编程源文件.c		C++源文件.cpp	C/C++头文件.h
		数据文件：用于存储数据的文件。文件操作主要指对数据文件的操作。
			二进制文件：以二进制为方式存储数据的文件
			文本文件：以文本为方式存储数据的文件
	文件指针
		定义格式：
			FILE *指针名;
			例：
				FILE *pf = NULL;
		作用：指向要操作的文件。通过该指针完成文件的操作。
	打开与关闭文件
		【记忆】文件的相关操作通过库函数完成
		打开文件：	fopen_s(文件指针地址，文件名，打开模式)   fopen(文件名，打开模式)
			例：		fopen_s(&pf, "1.txt", "r");
					pf = fopen("1.txt", "r");
			【记忆】打开模式，注意用双引号修饰：
					w只写
						如果文件不存在，则创建文件；如果存在，则打开文件并清楚内容
						返回的文件指针指向文件开头
					r只读
						如果文件不存在，则返回空指针
					a追加
						如果文件不存在，则创建文件，如果存在，打开文件。有文件后定位到末尾写入内容
						返回的文件指针指向文件末尾
					wb二进制只写		rb二进制只读		ab二进制追加
					w+	r+	a+		+表示可读可写	【建议】文件操作时，尽可能分别读写。实际操作中少用+
		关闭文件：	fclose(文件指针地址)
			例：		fclose(pf);
	读写文件：
		fgetc		从文件读取一个字符
			fgetc(文件指针);
		fputc		向文件写入一个字符
			fputc(文件指针);
		fgets		从文件读取一个字符串
			fgets(文件指针);
		fputs		向文件写入一个字符串
			fputs(文件指针);
		fprintf		格式化向文件写入一个数据
		fscanf_s	格式化从文件读取一个数据
		fwrite		向文件写入数据
			fwrite(写入数据的首地址,数据的总字节数,1,写入的文件指针);
			例：	char arr[16]="123456789";
				int a = 200;
				int b[16]={1,2,3,4,5,6,7,8,9};
				fwrite(arr,strlen(arr),1,pf);
				fwrite(&a,4,1,pf);				// 变量需要取地址，数组名本身传入的就是地址
				fwrite(b,4*16,1,pf);
		fread		从文件读取数据
			fread(数据读取后的存放地址,读取的字节数,1,读取的文件指针);
			int a = 0;
			fread(&a,4,1,pf);
		【记忆】文件的读写标准流程应该是：文件打开--文件读写--文件关闭。每一轮读写都应该重复打开和关闭的流程，而不是打开一次后多次读写再关闭。
	文件定位：
		【注意】实际操作中，文件指针是会随着需要变换文件中的位置的。文件指针指向哪里，就代表后续的读写是从哪里做起始点操作
		fseek	使文件内部指针指向文件某个位置
			SEEK_SET	文件起始位置
			SEEK_END	文件末尾位置
			SEEK_CUR	文件当前位置
			fseek(文件指针,偏移值,SEEK_SET);		//	偏移值为正数则表示往后偏移，复苏为往前偏移
			fseek(pf,10,SEEK_SET);				//	将文件指针定位到文件开头往后偏移10个字符的位置。
			fseek(pf,-10,SEEK_END);				//	将文件指针定位到文件末尾往前偏移10个字符的位置。
			fseek(pf,-10,SEEK_CUR);				//	将文件指针定位到指针当前位置往前偏移10个字符的位置。
		feof	检测文件是否到了末尾，如果是末尾，则返回true，否则返回false
			feof(文件指针)

文件流：
	流的概念：
	fstream的使用：C++中最常用的文件操作类。f指file，stream指流，即文件流类
	fstream常用的成员函数：
		需要先加载头文件：#include <fstream>
		fstream obj;
		obj.open("路径", 打开模式);	// 打开文件
		obj.close();				// 关闭文件
		obj.is_open();				// 判断文件是否打开
		obj.eof();					// 判断是否到达文件尾部
		obj.put();					// 向文件写入内容。前面需要先out方式打开文件
		obj.get();					// 读取文件内容（有多个重载函数）
		obj.write();				// 二进制写入
		obj.read();					// 二进制读取
		【注意】二进制读写效率会更高，但是文件编码就会不够直观
		例:
		fstream obj;
		obj.open("text_1.txt", ios::out);
		char ch = 'A';
		obj.put(ch);
		obj.put('B');
		obj.close();
		obj.open("text_1.txt", ios::in);
		char th = '';		//这两行代码可以替换成 char th = obj.get();
		obj.get(th);
		cout << th << endl;
		obj.close();
		// 二进制读写
		fstream obj;
		obj.open("text_2.txt", ios::out);
		int num = 99;
		obj.write((const char*) & num, sizeof(int));
		obj.close();
		obj.open("text_2.txt", ios::in);
		int val = 0;
		obj.read((char*)&val, sizeof(int));
		cout << val << endl;
		obj.close();
	文件打开模式：
		ios::app		// 追加模式。所有写入都追加到文件末尾
		ios::ate		// 文件打开后定位到文件末尾
		ios::in			// 打开文件用以读取。这里的命名视角是站在程序上，将文件内容读取入程序。
		ios::out		// 打开文件用以写入。这里的命名视角是站在程序上，将文件内容输出到文件。
		ios::trunc		// 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设置为0
		【注意】
			1、文件模式是可以多模式并行的
				例：obj.open("",ios::out | ios::trunc);	// 指将数据写入文件，并防止有同名重复文件产生
			2、用ios::out打开文件时，如果没有的话是会创建一个文件出来的
				例：
				obj.open("text_1.txt", ios::out);
				obj.close();
				// 程序运行结束后会在项目中创建一个"text_1.txt"文件
			3、切换文件打开模式时，一定要先关闭文件。
	文件指针：
		概念：文件打开时存在一个文件指针的。类似于记事本等文本软件的光标，用来标记操作位置。文件指针会随着文件的读写自动移动
		【记忆】执行.put()时，如果是用ios::out，而不是ios::app打开文件。写入内容时文件指针会自动回到文件头，之前已有的内容会被删掉。	
	使用重载的<<和>>符号
	

位图文件：
	相关概念：
		位图：
			位图图像（bitmap），也叫点阵图像或绘制图像。是由称做像素的单个点组成的。
			位图的图像质量是以单位长度内像素的多少来决定的。单位长度类像素越多，分辨率就越高，图像效果就越好。
			常见格式：BMP，GIF，GPEG，PNG等等
		色彩深度：
			也叫色彩位数。指图中要用多少个二进制位来表示每个点的颜色，是分辨率的重要指标。常用的有1位(单色)，
			2位（四色，CGA），4位（16色，VGA），8位（256色），16位（增强色），24位（真彩色）和32位等。
			色深16位以上的还有进一步分类。
		位图和矢量图：
			可自行了解
	文件结构：
		位图
			位图文件头
			位图信息
				位图信息头
					颜色表
			位图像素数据
	位图文件头：
		用于描述整个文件的情况，结构如下：
			struct BITMAPFILEHEADER		//	bit map file header	这是文件头结构，大小为14字节
			{
				WORD	bfType;			//	文件类型："BM" 表示是位图文件。
				DWORD	bfSize;			//	整个位图文件的大小
				WORD	bfReservedl;	//	WORD 和 DWORD 都是数据类型。WORD 字	2字节	DWORD 双字	4字节
				WORD	bfReserved2;	// 
				DWORD	bfOffBite;		//	颜色的首地址举例文件开头的字节数  54字节
			}
	位图信息头：
		用于分配内存，设置调色板信息，读取像素值等
			struct BITMAPINFOHEADER				//	bit map info header	该结构体总大小为40字节
			{
				DWORD      biSize;				//	本结构体的大小（sizeof(BITMAPINFOHEADER)）	28 00 00 00 
				LONG       biWidth;				//	以像素为单位的图像宽度
				LONG       biHeight;			//	以像素为单位的图像长度
				WORD       biPlanes;			//	目标设备的位平面数							01 00
				WORD       biBitCount;			//	位深度：每个像素的位数								
				DWORD      biCompression;		//	图像的压缩格式								这个值几乎总为0
				DWORD      biSizeImage;			//	颜色信息占的字节数（指位图像素数据的大小）
				LONG       biXPelsPerMeter;		//	水平方向每米的像素个数						通常为0
				LONG       biYPelsPerMeter;		//	垂直方向每米的像素个数						通常为0
				DWORD      biClrUsed;			//	调色版中实际使使用的颜色数	通常为0
				DWORD      biClrImportant;		//	现实位图必须的颜色素							通常为0
			};
	【记忆】位深度：
		0	用在JPEG格式中
		1	单色图，调色版中有两种颜色，就是黑白图片
		4	16色图
		8	256色图，常说的灰度图
		16	64k图，一般没有调色板，每两个字节表示一个像素，5或6个位表示一个RGP分量
		24	16M真彩色图，一般没有调色板，每3个字节表示一个像素，一个字节表示一个RGP分量
		32	4G真彩色，一般没有调色板，每4个字节表示一个像素，相对于24位多一个透明度
	颜色表：
		一般针对16位以下的位图而设置。对于16位以上的位图，每个像素数据单元存储的数据就是该像素点对应的颜色数据，就没有调色板。
		对于16位以下的位图，因为颜色种类不多（8位最多256种颜色），所以用一个表将颜色数据存储，而在像素数据种，每个单元存储的
		是该像素对应颜色所在的表的下标索引。
	位图像素数据：
		位图的主体部分。不同的位图深度，每个位图数据占据的字节数也不一样。
		【记忆】位图像素数据大小计算：
			举例：24位位图文件位图像素数据占的字节数（biSizeImage）的计算方法：
				linecount = biWidth * 3;				每个像素3字节
				int t = linecount % 4;
				linecount += (t ? (4-t) : t);			对齐规则要求：横向的总字节数必须是4的整数倍，否则要补字节。
				biSizeImage = biHeight * linecount; 	得出总字节数。

算法：
	算法：
		概述：在电脑程序上，追求以最少的内存，和最少的计算次数（最少时间），完成目标计算的方法，即为算法。小到一个函数，大道整个程序，都可以抽象成算法。
		作用：在电脑软硬件的限制下，完成各种计算，提高用户的使用体感。
		侧重：随着电脑软硬件的发展，新的算法方向主要集中在AI、3D建模渲染和大数据并发方向，以及互联网相关。（纯个人理解）
			在实际运用中，如果计算次数和内存使用不可兼得，推荐使用减少计算次数（最少时间）的算法。具体情况需要程序员自己把握
				现在堆内存比较容易，且当下的用户对时间更敏感
				使用内存但是总体花费时间少，也是一种节约内存的方法
	排序：
		【记忆】排序稳定性：在排序的序列当中，如果有两个相同的数，在排序前后相对位置都一样，叫稳定排序。
				冒泡排序位稳定排序，选择排序位非稳定排序
		（下面的排序方向都为从小到大）
		概述：排序算法是非常经典的一种现实应用，常见的算法如下：
		冒泡排序：从第一个数开始，依次做为选数，和后一个数对比，只要比后一个大，就交换两个数的位置。
			本质是通过逐个对比，一轮轮将最大的数交换到最后面。如同气泡般从小往大冒泡。
			优缺点：耗时最长，数据交换频次最高，占用内存小（不过内存占用时长最长）
			BubbleSort(数组首地址,数组长度)
			void BubbleSort(int* arr,int len)
			{
				int j,t;
				for (int i = len-1;i > 0; --i)
				{
					for (j = 0;j < i; ++j)
					{
						if (arr[j] > arr[j+1]) 
						{
							t = arr[j];
							arr[j] = arr[j+1];
							arr[j+1] = t;
						}
					}
				}
			}
		选择排序：个人理解是对冒泡的优化。
			在冒泡基础上增加变量k记录最小值的下标，每一轮都用k的数据和后面的对比，有更小的就更新k值,一轮对比完如果k如果不是选数下标就和选数交换。
			优缺点：和冒泡比，循环次数一样，增加了内存使用，数据交换频次最少，整体耗时更少。
			SelectSort(数组首地址,数组长度)
			void SelectSort(int* arr,int len)
			{
				int i,k,j,t;				// 【注意优化】进入函数时最好将要用到的变量提前定义，后面使用只需要赋值。免的后面循环的开辟关闭内存空间。
				for (i = 0;i < len-1; ++i)
				{
					k = i;
					for (j = k+1; j < len; ++j)
					{
						if (arr[j] < arr[k])	//【注意】可以传入一个bool类型参数p：if (p?arr[j] < arr[k]:arr[j] > arr[k])，即可控制升序还是降序排序
							k = j;
					}
					if (i != k)
					{
						t = arr[i];
						arr[i] = arr[k];
						arr[k] = t;
					}
				}
			}
		快速排序：每一轮递归循环，标记开始下标的数据b、k,将b和后续数据j对比。后续数据只要比b小，k值+1，则k指向第一个比b大的数,
				k和j值不同就交换，则k一定指向最后一个比b小的数。当轮结束，交换kb数据，则所有比k小的都在k前面。此时k值就是k排序完成后的下标。
				然后以b的下标为原点，将[0 ~ b-1]和[b+1 ~ 0]作为开始结束下标，递归计算
			优缺点：耗时非常短，循环次数最，数据交换频次较多
			QuitSort(数组首地址,开始下标,结束下标)
			void QuitSort(int* arr, int b, int e)
			{
				if (b < e)
				{
					int k = b;
					int t;
					for (int j = b + 1; j <= e; ++j)
					{
						if (arr[j] < arr[b])
						{
							k++;
							if (k != j)
							{
								t = arr[k];
								arr[k] = arr[j];
								arr[j] = t;
							}
						}
					}
					if (b != k)
					{
						t = arr[b];
						arr[b] = arr[k];
						arr[k] = t;
					}
					QuitSort(arr, b, k - 1);
					QuitSort(arr, k + 1, e);
				}
			}
		归并排序：通过递归，将数组划分为多个单数据的数组，将相邻的两个数组按照两个顺序数组合并方式排好序。
				已排好序的数组递归上浮，与相邻的数组一起，又构成两个顺序数组合并，
				以此类推，直到整个数组排序完成。
			优缺点：耗时非常少，循环次数较少，每次循环都有数据的赋值，需要有缓冲数组占据内存，不过内存占用时间短。
			MergeSort(数组首地址,开始下标,结束下标，缓冲数组首地址)		//【注意】缓冲数组大小要和排序数组一样
			void MergeSort(int* arr, int b, int e, int* temp)
			{
				if (b < e)
				{
					int m = (b + e) / 2;
					MergeSort(arr, b, m, temp);
					MergeSort(arr, m + 1, e, temp);
					int i = b;
					int j = m + 1;
					int k = b;
					while (i <= m && j <= e)
					{
						temp[k++] = (arr[i] < arr[j]) ？arr[i++] ：arr[j++]；
					}
					while (i <= m)
					{
						temp[k++] = arr[i++];
					}
					while (j <= e)
					{
						temp[k++] = arr[j++];
					}
					for (int a = b; a <= e; ++a)
					{
						arr[a] = temp[a];
					}
				}
			}
			【记忆】两个升序数组合并为一个升序数组
			Merge（数组1首地址,数组1长度,数组2首地址,数组2长度,合并数组首地址）		【注意】合并数组长度必须大于等于数组1和2长度之和
			void Merge(int* arr, int lenarr, int* brr, int lenbrr, int* crr)
			{
				int i = 0;
				int j = 0;
				int k = 0;
				while (i < lenarr && j < lenbrr)
				{
					crr[k++] = (arr[i] < brr[j]) ? arr[i++]: brr[j++];
				}
				while (i < lenarr)
				{
					crr[k++] = arr[i++];
				}
				while (j < lenbrr)
				{
					crr[k++] = arr[j++];
				}
			}
	查找：
		概述：查找算法是非常经典的一种现实应用，常见的算法如下：
		折半查找：
			查找一个数据在一个已排好序的数组的下标。到得到就返回下标，没找到就返回-1。
			HalfSearch(查找目标数组首地址, 数组长度, 查找数据)		//【注意】这里的数组应该先做排序
			int HalfSearch(int* arr, int len, int value)
			{
				int b = 0;
				int e = len - 1;
				while (b <= e)
				{
					int middle = (b + e) / 2;
					if (value < arr[middle])
						e = middle - 1;
					else if (arr[middle] < value)
						b = middle + 1;
					else
						return middle;
				}
				return -1;
			}
	数组乱序：
		fun(数组首地址, 数组长度)
		void Luan(int* arr, int len)
		{
			int sj, temp;
			for (int i = len; i > 0; --i)
			{
				sj = rand() % len;
				temp = arr[sj];
				arr[sj] = arr[i - 1];
				arr[i - 1] = temp;
			}
		}
	变量交换
		1、用第三个变量周转
			int a = 1, b = 2;
			int c = a;
			a = b;
			b = c;
		2、用加减法（主要适用于整型）
			int a = 1, b = 2;
			a = a + b;
			b = a - b;
			a = a - b;
		3、异或位运算法
			int a = 1, b = 2;
			a = a ^ b;
			b = a ^ b;
			a = a ^ b;
	随机数和伪随机数
		随机数：现实中有很多概率计算的需求，就需要随机数。C++中库函数rand()可以生成一序列随机数。
			a是分子，b是分母   返回当前是否在b分之a的概率内。
			bool getRand(int a, int b)
			{
				return (rand() % b) < a;
			}
		但是rand()实际上是个伪随机数，即条件一样的情况下，随机出来的值永远固定，所以需要设置随机数的种子，增加随机性
			srand((unsigned int)time(NULL))	;
			【提示】只需要设置一次就够了，需要写在rand()调用的前面。
			这样就是在rand()的计算公司中，添加了一个不同时间不同值的一个变化的参数，每次随机出来的值就不一样了。
		【注意】	rand()和srand()需要包含头文件<stdlib.h>
				time()需要包含头文件<time.h>

基础数据结构
	线性表：
		表中数据呈线性排列。是将表中数据依次连续存放在计算机内存里的一种数据结构。表中相邻数据的地址也是相邻的。
		比如数组就是线性表的一种。逻辑位置（下标）连续的数据，其存储地址也是物理上连续的。
	顺序表：线性表的一种。
		【可用操作】增、删、查、改
		struct _ARRLIST_HEAD_	// 所有表都要有的表头结构
		{
			int* data;			// 顺序表数据首地址，实际使用时可当做数组名用。data的类型也可以是别的符合数据类型
			int len;			// 顺序表长度，指有多少个数据
			int size;			// 顺序表大小，指容量。size要大于等于len。因为顺序表每次扩容和缩减都需要重新开堆，所以引入容量概念，减少开堆次数。
		};
	链表：
		链表的和线性表的区别在于，其存储的数据元素，存储地址是不连续的。是独立分布在内存上的数据节点，节点之间的逻辑位置关系，
		依靠指针指向来联系。即每个数据节点都有一两个指针，指向下个数据或上个数据所在的地址。
		基于链表的特点，所以链表有分单向（指针指向下一个数据地址）和双向（有两个指针分别指向上下数据地址）。
		同时也有独特的环状结构，即列表表头和表尾的数据节点指针互指（环状或双向环状）
		【可用操作】增、删、查、改		
		struct LinkData			// 链表必须有的数据结构，data也可以是别的符合数据类型
		{
			int data;			// 链表数据
			LinkData* pre;		// 上一个数据地址。只有双向链表才有这个指针数据
			LinkData* next;		// 下一个数据地址。
		};
		struct _LINKLIST_HEAD_
		{
			LinkData* data;		// 链表表头的首地址。链表数据元素只能是复合数据类型。
			int len;			// 链表长度，指有多少个数据。基于链表的特性就不需要size了。
		};
		【双向链表和单向链表】双向链表也是环形链表。相比入单向链表，在查找数据方面更有优势。可以顺序和逆序查找。
	栈：和队列一样都是操作受限的线性表
		用顺序表表示更简单。
		特点：先进后出
			可以理解为一端开口的杯子，只有一个口子存取数据。先存的数据要等后存的数据取走后才能或取。
			开口端可操做称为栈顶，另一端为栈底。
		【可用操作】出栈、入栈、得到栈顶元素、判断栈满或栈空
		struck Stack	// 顺序结构的栈
		{	
			int size;	// 栈的大小容量
			int* data;	// 栈数据的首地址
			int top;	// 栈顶游标：栈内数据的个数。当top>=size时，表示栈满，top为0时，表示栈空。top-1为栈顶数据的下标。
		};
		【注意】出栈的操作可以不用删除已有数据，直接top--即可。
	队列
		用链表表表示更简单。
		特点：先进先出
			可以理解为现实总的排队。队尾入，队头出。
		【可用操作】出队、入队、得到队头队尾元素
		struct NodeData			
		{
			int data;			// 队列数据
			LinkData* next;		// 下一个数据地址。	没有逆序查找的需求，不需要上一个指针。
		};
		struct _QUEUELIST_		// 因为只会操作队头和队尾，所以不会有长度概念的需要
		{
			NodeData* head;		// 队头的首地址。
			NodeData* end;		// 队尾的首地址。
		};
	MAP（哈希表）：
	内存池：
	二叉树：
	树形结构：

STL容器：全名为标准模板库（Standard Template Library）
	认识：STL 基于 泛型编程 思想，包含六大组件：
			容器：		存储和管理数据集合						list、map、vector等
			算法：		对容器中的数据的处理（排序查找等）			sort、find、transform等
			迭代器：		链接容器和算法的桥梁，提供统一访问接口		begin()、end()
			函数对象：	行为类似函数的对象						greater<int>、自定义仿函数
			适配器：		调整容器或函数对象的接口					stack、queue、priority_queue
			分配器：		管理容器内存分配（通常无需程序员操作）		allocator<T>
		【总结】即对容器和容器类数据的管理和计算
	容器分类：
		序列容器（顺序存储）
			vector			动态数组，支持快速随机访问				尾部插入 O(1)，中间插入 O(n)
			deque			双端队列，头尾插入高效				头尾插入 O(1)，中间插入 O(n)
			list			双向链表，支持高效插入/删除			任意位置插入 O(1)
			forward_list	单向链表（C++11），内存更省			前插 O(1)，无反向迭代器
			array			固定大小数组（C++11）					随机访问 O(1)，大小不可变
		关联容器（有序/无序键值对）
			set				红黑树，有序唯一键集合				查找O(log n)
			multiset		红黑树，有序可重复键集合				查找O(log n)
			map				红黑树，有序键值对（唯一键）			查找O(log n)
			multimap		红黑树，有序键值对（可重复键）			查找O(log n)
			unordered_set	哈希表实现的无序唯一键集合（C++11）	查找平均 O(1)，最差 O(n)
			unordered_map	哈希表实现的无序键值对（C++11）		查找平均 O(1)，最差 O(n)
		容器适配器
			stack			栈，双端队列实现						后进先出（LIFO）
			queue			队，双端队列实现						先进先出（FIFO）
			priority_queue	vector（默认）						优先级队列（默认大顶堆）

	
C++异常处理机制：
	异常概念：指程序在运行过程中出现了预料之外的情况。
	处理机制：C++ 异常处理机制用于处理程序运行时可能发生的错误，使代码更具健壮性和可维护性。其核心组件包括 try、catch、throw，并支持自定义异常类。
		实际代码编写中，程序员需要预见某些代码有更高出错的概率，于是使用异常机制进行预处理。
	核心语法：
		抛出异常 (throw)：使用 throw 抛出异常对象（可以是基本类型、字符串、类对象等）
		捕获异常 (try-catch)：用 try 块包裹可能抛出异常的代码，catch 块捕获并处理异常
			try
			{
				代码段A
				直接或间接有throw
				代码段B
			}
			catch(接收异常)
			{
				处理代码
			}
		基本流程：当代码执行完A时，如果有问题，就会抛出throw，然后catch接受异常，执行处理代码，代码段B就会被跳过。
				当代码执行完A时，如果没有问题，就会继续执行代码段B。也跳过后面的处理代码。
			编程思路：
				遇到问题==>打报告==>throw抛出异常信息==>打报告==>打报告
		【记忆】try-catch是可以嵌套的。比如在代码段AB和处理代码中，是可以有多重嵌套的。所以try-catch是有层级的。
		【提示】只要有抛出throw，就必须有一个catch来接收处理。如果没有，就会被下一层catch捕获。catch类似switch-case，可以多个并行，根据抛出异常的不同来执行不同的处理代码。
		例：
		double testFunc(double a,double b)
		{
			if(b == 0.0)
			{
				throw "这里参数有问题";
			}
			return a/b;				// 一旦有throw抛出异常，后面的代码就自动跳过了
		}
		try
		{
			cout << testFunc(9, 0) << endl;
		}
		catch(const char* str)
		{
			cout << str << endl;
		}
		catch(int num)
		{
			cout << num << endl;
		}
		catch(...)	// 这个表示“其他”，即如果抛出没有进上面的选项，就进这个
		{
			cout << "不对劲" << endl;
		}
	异常类型：
		标准异常类stdexcept：C++ 提供了一系列标准异常类，均继承自 std::exception
		使用时要加载头文件#include <exception>
			std::logic_error	逻辑错误（如无效参数）
			std::runtime_error	运行时错误（如文件未找到）
			std::out_of_range	数组/容器越界访问
			std::bad_alloc		内存分配失败（new 抛出）
		自定义异常类：可以继承 std::exception 定义自己的异常
			【提示】可以看到，exception类只有一个公有虚函数what()
			例：
			class MyException :public exception
			{
			public:
				char const* what() const
				{
					return "自定义异常处理";  // 【注意】提示文本上，建议使用英文。因为有些平台中文可能出错
				}
			};
			try
			{
				throw MyException();
			}
			catch (MyException& obj)
			{
				cout << obj.what() << endl;
			}
	异常处理机制特点
		栈展开（Stack Unwinding）
			当异常抛出时，程序会逆向回溯调用栈，直到找到匹配的 catch 块。
			在回溯过程中，局部对象会自动调用析构函数（RAII 机制）。
		异常安全
			基本保证：异常发生后，程序状态仍然有效（无资源泄漏）。
			强保证：操作要么完全成功，要么完全回滚（事务性）。
			无异常保证：函数承诺不抛出异常（C++11 后可用 noexcept）。
		性能影响
			异常处理比普通返回码稍慢，适用于不可恢复的错误（如内存不足、文件损坏）。
			频繁的小错误建议用返回值或 std::optional 代替。
	总结:异常机制用于处理不可预期的运行时错误，结合 RAII 可写出更健壮的代码。


	
	
图形界面：
	#include <graphics.h>
	坐标体系：
		左上角为原点，从左到右为x轴，从上到下为y轴。以此为基准绘制。
	贴图三部曲：
		定义变量
			定义一个图片类型的变量
		加载图片
			将图片资源加载到程序中
		贴图
			将图片显示在界面上。
			需要设定好图片显示的位置和大小（x,y,w,h）。
			
游戏/程序设计模式：
	单例模式：
		一个类只能创建一个类对象
		例：
		class Player
		{
		private:
			Player();
			static Player* _THIS_;
		public:
			~Player();
			static Player* _getPlayer();
		};
		Player* Player::_THIS_ = NULL;
		Player::Player()
		{
		}
		Player::~Player()
		{
		}
		Player* Player::_getPlayer()
		{
			if (NULL == _THIS_)
			{
				_THIS_ = new Player();
			}
			return _THIS_;
		}
		Player* palyer = Player::_getPlayer();
	工厂模式：
		



查找错误方式：
	1、生成（Ctrl + B）解决方案/重新生成解决方案：语法错误时会编译失败。在输出栏能看到错误警告或提示。
	2、调试（Ctrl + F5）开始执行：运行代码，逻辑错误则会失败报错。
