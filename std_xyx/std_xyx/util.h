#pragma once
#include <random>
#include <cmath>
#include <stdexcept>
#include <string>

#define _PI_ acos(-1)
#define _WIN_W_ 1280
#define _WIN_H_ 720
#define _FPS_ 60
#define _DE_BUG_ true
//#define _DE_BUG_ false

/*工具类文件*/

/*
* 获取随机整数
* @min = 0	最小值
* @max = 1	最大值
*/
inline int getIntRand(int min = 0, int max = 1)
{
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<int> dist(min, max);
	return dist(gen);
}

/*
* 获取随机浮点数
* @min = 0.0	最小值
* @max = 1.0	最大值
*/
inline float getRealRand(float min = 0.0, float max = 1.0)
{
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_real_distribution<float> dist(min, max);
	return dist(gen);
}

/*
* 获取随机高斯分布数值
* @<T>			类型模板：int float double...
* @mean			均值
* @std_dev		标准差
*/
template <typename T>
inline T getRormalDistributionRand(T mean, T std_dev)
{
	std::random_device rd;
	std::default_random_engine gen(rd());
	std::normal_distribution<T> dist(mean, std_dev);
	return dist(gen);
}

/*
* 判断点和矩形是否碰撞
*/
template <typename T>
inline bool checkPointToRect(const T x, const T y, 
	const T left, const T right, const T top, const T bottom)
{
	return x >= left && x <= right && y >= top && y <= bottom;
}

/*
* 判断矩形和矩形是否碰撞
*/
template <typename T>
inline bool checkRectToRect(const T pleft, const T pright, const T ptop, const T pbottom, 
	const T left, const T right, const T top, const T bottom)
{
	return pleft <= right
		&& left <= pright
		&& ptop <= bottom
		&& top <= pbottom;
}

/*
* 判断矩形和水平线段
*/
template <typename T>
inline bool checkRectToHLine(const T pleft, const T pright, const T ptop, const T pbottom, 
	const T left, const T right, const T y)
{
	return pleft <= right
		&& left <= pright
		&& ptop <= y
		&& y <= pbottom;
}

/// <summary>
/// 角度转弧度
/// </summary>
/// <param name="angle">角度值</param>
/// <returns>弧度值</returns>
inline double getRadiansByAngle(double angle)
{
	return angle * _PI_ / 180;
}

/// <summary>
/// 弧度转角度
/// </summary>
/// <param name="radians">弧度值</param>
/// <returns>角度值</returns>
inline double getAngleByRadians(double radians)
{
	return radians * 180 / _PI_;
}

inline bool splitByLastChar(const std::string& str, const char delimiter, std::string& name, int& size ) {
	// 查找倒数第一个分隔符的位置
	size_t lastPos = str.rfind(delimiter);

	if (lastPos == std::string::npos || lastPos == str.size() - 1) {
		// 未找到分隔符或者没有数字后缀
		return false;
	}
	name = str.substr(0, lastPos);
	std::string num = str.substr(lastPos + 1);
	try {
		size = std::stoi(str);
	}
	catch (const std::invalid_argument&) {
		//"数字部分含非数字字符: "
		return false;
	}
	catch (const std::out_of_range&) {
		//"数字超出 int 范围: "
		return false;
	}
	return true;
}