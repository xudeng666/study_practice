2025-8-11
	计划将幸存者、大乱斗、空洞武士、拼好饭和致命打鸡五个游戏融合到一个游戏中。
	
	整理各个游戏的特点:
		小游戏：本项目主体。
			游戏选择界面，可选择游戏。选择后进入该子游戏游戏界面。
			要求：每个子游戏必须有一个开始界面，用于游戏开始或退出到上一级。
		幸存者
			开始界面：
				进入、退出、重玩等功能按钮
			游戏界面：
				角色
				子弹
				怪
				碰撞
				不可点击
				没有光标
		空洞武士
			开始界面：
				进入、退出、重玩等功能按钮
			游戏界面：
				地面-下中锚点
				角色
				怪
				子弹
				AI状态机
				碰撞
				不可点击
				没有光标
		大乱斗
			开始界面：
				进入、退出、重玩等功能按钮
			选角界面：
				角色选择
				不可点击
				没有光标
			游戏界面：
				地面-下中锚点
				云台
				角色
				技能
				子弹
				碰撞
				不可点击
				没有光标
				血条
		致命打鸡
			开始界面：
				进入、退出、重玩等功能按钮
			游戏界面：
				炮座
				炮塔
				子弹
				碰撞
				光标替换
		拼好饭
			开始界面：
				进入、退出、重玩等功能按钮
			游戏界面：
				外卖员
				饮料堆
				餐品堆
				外卖盒堆
				微波炉
				外卖摆放格子
				光标替换
			
	
	需要完成的内容：
		资源管理：所有项目资源的自动加载、释放、绘制
			资源类型：
				图片
				图集
				音乐
			资源池：		代码完成
				纹理
				音频
			代码：
				动画类
		游戏管理
			游戏分类
			游戏的切换
				加载
				运行
				退出
		场景管理
			需要思考和游戏管理的关系
			场景的切换
				加载
				运行
				退出
		对象管理
			将所有游戏对象统一纳入管理
			找到共同点，设定基类
				尺寸
				资源
				坐标
				坐标对齐类型
			对象设定：
				游戏对象：位置，尺寸，
					
		碰撞管理
			需要思考和对象管理的关系
			位置
			碰撞尺寸
			是否开启碰撞
			碰撞类型
			
2025-8-12
	资源管理代码
		图片资源池		都是png
			kdws 有图集
		音效资源池		mp3、wav
		背景音乐资源池	mp3
	尝试所有资源打包成图集处理
2025-8-13
	资源不再打包，图集资源拆分。
	游戏类中并入各种管理器，根据游戏不同情况设立
		角色管理器
		碰撞管理器
		场景管理器
	将开场界面算作游戏0。
	不同游戏的入场加载资源和设置初始化游戏数据，退场清空。
	考虑下资源池是否也要同步清空？
		不清空的话，再次进入游戏需要思考不做二次加载
		清空的话每次切换游戏都要再加载一次资源
2025-8-15
	游戏对象
		动画
		图片
		按钮
	将点击区域合并到对象基类中
		按钮类待完成
2025-8-20
	需要重新思考，关于游戏对象基类，图片，按钮，动画，角色，碰撞箱等基础对象的结构。
	基类：
		位置
		大小
		方向（角度）
		锚点
		点击区域
		是否可点击
		图片：
			图片资源
			动画
				定时器
				帧索引
				资源名和帧总数
				是否循环
				回调函数
		碰撞箱：
			是否可碰撞
			碰撞回调
			自身碰撞层
			目标碰撞层
	角色：
		位置
		大小
		方向（左右）
		锚点
		速度
		状态机
		是否重力模拟
		是否无敌
		无敌闪烁定时器
		无敌状态定时器

2025-8-22
	打算将UI树给概念加入游戏框架，又要大规模该代码了：
		场景基类添加UI树根节点指针
			一个场景通过UI树统一UI对象的增删查改。
			添加增删查改相关代码
		场景基类添加UI对象嘻哈表，通过唯一标识符"对象名"快速查找，就不用遍历UI树。
		将GameObj类改为UI树节点：
			添加父节点指针，和子节点链表指针。
			添加增删查改相关代码
			添加对象对齐方式和相关代码
			等等（还需要细想）
		需要添加新的对象尺寸计算方式。
		等等（还需要细想）
		

2025-8-23
	SDL有现成的纹理采样过滤模式，可直接用
	平铺和拉升需要自己写
	
	越做越多了。优先完成游戏开发。
		先完成对象树
			如此，游戏中所有对象都可以统一调用处理了，前面的先渲染，后面的后渲染
			暂时添加三个绘制层：
				地图
				游戏
				UI
		然后完成图片的平铺和拉伸	
		其他功能暂时不做新增
2025-8-24
	对象树做好了，但是运用到已有的两个场景发现bug：
		运行游戏时，偶尔情况下按钮只显示一个。
	还需要完成的任务：
		相对坐标体系待完成：
			所有对象的坐标，都只是对象自身锚点和父节点锚点的相对坐标。
		图片的拉伸和平铺未完成
			思路：这里主要是计算对象显示尺寸和方式，且并不真的修改设定的尺寸，只是让设定的尺寸无效或部分无效。
				所以这里主要在绘制层做文章。on_render函数上要多写点if。
		
2025-8-25
	坐标体系以及计算完成
	图片的拉伸和平铺：
		功能开发完成，但是在新界面验证中出了问题。明天再说了
		
2025-8-26
	拉伸和平铺，以及对应的进度条组件做好了。目前没有发现问题。
	将血量进度条加入了幸存者游戏界面中。
	下一步是要做文本渲染:
		先要做字体资源的资源池。要求是调用时，发现没有再添加到资源池。和之前的资源加载不一样。
		字体和图片不一样，经常要设置颜色等，所以渲染节点应该使用SDL_Surface，在转换成SDL_Texture渲染。
		功能规划：
			字号
			颜色
			文本内容
				可否在一个文本中，表现出多种颜色？
			需要考虑文本换行、锚点等多种形式
			阴影	
				是否开启
				阴影颜色
				阴影和正文相对位置
			暂定以上这些
			
2025-8-27
	基本完成了字体的加载和获取功能
	字体组件完成少部分
	完成上述工作时发现将窗口、渲染器和相机都放在游戏管理器中不合适，于是将三者拿出来单独包装成一个game_wnd类。
	然后发现游戏的引用体系有问题，然后越调越乱了。明天重新梳理下整个项目的include吧！
	
2025-8-28
	main
		<SDL.h>
		<SDL_ttf.h>
		<SDL_image.h>
		<SDL_mixer.h>

        <chrono>
        <thread>
        
        "game_wnd.h"
           
		game_mgr.h			单例。游戏管理器，记录当前运行游戏类型，管理游戏运行和切换。
			game.h			游戏基类，游戏管理器的管理对象。里面内置了场景管理器，用于记录当前运行场景和切换场景
				scene.h		场景基类，场景管理器的管理对象。用于生成游戏UI、地图和角色等。包含游戏对象树相关内容
					<queue>				对象树层次遍历需要	
					<functional>
					<SDL.h>	
			game_type.h
				<string>
				<iostream>
		"game_obj.h"		游戏对象基类，包括图片、动画、按钮、文字、进度条都基于此。以及资源调用。也是对象树节点，包含父节点指针和子节点链表。
			<forward_list>		子节点链表所需
			<functional>		用于按钮点击，或者动画播放回调
			<SDL.h>
			game_type.h
				<string>
				<iostream>
			vector2.h
				util.h
					<random>
					<cmath>
					<stdexcept>
					<string>
		res_mgr.h			单例。资源管理器。用于资源的加载、释放、获取和资源池管理。游戏是基于SDL库。
			<SDL.h>
			<SDL_image.h>
			<SDL_mixer.h>
			<SDL_ttf.h>
			<unordered_map>		用于建立资源池。
			game_type.h
				<string>
				<iostream>
				
		game_wnd.h			单例。统一了游戏窗口、renderer渲染器和摄像机。
			camera.h			摄像机类，用于实现画面抖动效果
				timer.h"			定时器
					<functional>
				vector2.h"			坐标计算
					util.h
						<random>
						<cmath>
						<stdexcept>
						<string>
				game_type.h"
					<string>
					<iostream>
				<SDL.h>

2025-8-29
	将文本组件添加到场景中，简单测试后基本能用。
	下一步将添加角色和怪物。需要验证下动画组件是否可用。
	角色基类完成部分，动画类修改了部分
		计划角色类中，这届将UI组件添加到对应的层接节点。
		
2025-8-30
	初步将角色添加到场景。下一步需要完善角色移动功能。
	

2025-9-1
	在角色基类中，分割幸存者角色基类。
	完善角色移动转向和屏幕范围限定功能。
	下一个是角色子弹功能。
	再然后是敌人
	最后是碰撞箱

2025-9-2
	数值成长，依据角色得分：
		每20分加一颗子弹
		每15分家0.08速度
		每10分敌人生成间隔减少10%
	当子弹少于3颗时，怪物生成速度降低10%，持续10秒
	
	今天完成了子弹的飞行。
	记得用这个函数来计算子弹（线段）和敌人的碰撞
	SDL_bool SDL_IntersectRectAndLine(
		const SDL_Rect* rect,    // 目标矩形（整数坐标）
		int* startx, int* starty, // 线段起点（输入/输出）
		int* endx, int* endy     // 线段终点（输入/输出）
	);
	需要再思考碰撞箱的底层构架。
	另外需要将分数和游戏中的数值关联起来

2025-9-13：
	任然没解决退出游戏时，二次释放的问题。
		
2025-9-15：
	打算重做对象树系统。将树节点和对象类分离开来，同时运用智能节点。
	要点：
		游戏对象系列类：
			只处理游戏对象逻辑和数据，将现有的节点相关内容移除，实现业务类和节点的解绑
		多叉树相关：
			定义一个多叉树单例管理类，封装遍历方法，固定根节点已经UI、游戏和地图等节点。
			将进场、退场、更新、事件和绘制方法public
			节点封装自身的更新、绘制等逻辑，管理类负责遍历调度
			使用智能节点。多用weak_ptr缓存常用节点避免内存泄漏
			未来还可以参考脏标记和分帧更新思路。不过本次开发体量极小，不过度设计。
		业务类和节点类的接口：
		
		对象的遍历：
			前序遍历：
				入场
				更新
				事件
				渲染
			后序遍历：
				退场
			层序遍历
				暂无
		遍历优化：
			分帧遍历
				游戏体量极小，暂时不用
			事件总线
				可以加上
			延迟增删
		场景和游戏层设计：
			将场景和游戏指针统一改为智能指针：std::shared_ptr
			将场景对象的构造移动到入场，退场则后序遍历删除掉
			强化退场函数的清理逻辑，避免内存泄漏

2025-9-16：
	计划下游戏框架最终想要达成的效果。以及当前的进度
	计划：
		1、将渲染节点和渲染对象区别开来，渲染对象为节点的成员。
			难点在于在对象中获取自己所在的节点
			以及涉及到的，锚点对象相关的坐标、透明度（看情况是否加上）、旋转计算
			要结合问题2中智能指针
		2、进可能使用智能指针，不再使用原始指针/裸指针，几乎所有代码都要重写
			游戏指针
			场景指针
			节点指针
			对象指针
			资源指针
		3、将进场、退场、更新、事件和渲染，以及类型名相关独立抽出来作为抽象类Obj。
			以后无论是场景、游戏、对象，都可以继承Obj。
		4、新增对象树管理器，从场景基类中抽离出来。整个游戏只要一个根节点。
		5、添加事件总线和延迟增删功能。
		6、其他，后面在补充
	进度：
		基本完成Obj抽象类，优先改造GameObj对象类（难点）。
		对象树管理器和节点类已经新建文件，但还没有开始完善代码功能。
	想要解决的问题：
		除了节点里面的对象指针，其他指针是否都不合适用unique_ptr，需要进一步验证
		创建接口，能够在对象中获取所在节点
		

2025-9-17：
	今日完成：
		节点和节点树管理器基础功能开发完毕
		场景基类功能单一化调整完毕
		调整了obj抽象类，添加了ID和相关读写代码
		修改了游戏对象基类少部分代码
		修改了游戏基类部分代码
	明日计划：
		优先完成游戏基类和游戏管理器的修改
		再次完成资源管理器相关修改
		再逐个完成对象类的修改
		各个游戏和场景派生类的调整，等游戏对象类改完再看吧
		
2025-9-18：
	今日完成：
		游戏类和游戏管理器的修改
		资源管理器相关暂时不改
		完成对象基类修改
	明日计划：
		逐个完成对象类的修改
			图片 动画 文本 按钮 碰撞箱等
		各个游戏和场景派生类的调整，等游戏对象类改完再看吧
		
2025-9-19：
	今日完成：
		完成了除了幸存者场景相关的其他内容。
	明日计划：
		先一口气改完幸存者所有代码，然后再统一测试
		
2025-9-20：
	今日完成：
		修改了节点获取数据的方式
		修改了幸存者、角色、和部分敌人类
	后日计划：
		明天休息，后天继续改
		
2025-9-22：
	今日完成：
		基本完成所有智能指针相关修改，编译遇到两个bug。
		一个是工厂模式，要修改字符串参数的传入
		一个是节点和数据类的相互识别。编译器在node的编译中没有识别出数据类报错。
		做了前置声明，依旧如此。明天再说吧。
		
2025-9-23：
	今日完成：
		工厂模式，要修改字符串参数的传入：已解决，是派生类都应该添加带参构造。派生类如果没有写明带参构造，是不会自动匹配基类的带参构造的。
		目前最大的问题还是节点和对象之前依赖问题理不清楚。干脆还是写到一起。只是用GameObj继承节点类。节点相关的代码严格限制在节点类的文件中。不然代码改动实在太大了，而且还有很多东西理不清楚。
		小项目就不该过度设计
		
		重新构建了节点和数据之间的关系。修改成了数据继承节点类。并初步觉得用工厂模式，通过模板方式生成obj对象。
	明日计划：
		所有涉及到对象生成的部分都要再改。
		目前改好的只有obj基类和node基类和管理类。
		
		
2025-9-24：
	今日完成：
		基本上改完了节点和数据基类融为一体的相关代码。
	问题：
		我最开始的设计思路，是每个场景都有个根节点，有自己独立的渲染树。
		但是后面改动中，将这个基础改成了全游戏共用一个渲染树。
		而当前的游戏框架设计是：
			游戏一开始就都定义好所有的游戏和场景
			且场景在初始化时就创建好了所有对象，且添加到个各个场景中的渲染树中
			且游戏资源根据当前游戏，只会加载当前游戏相关资源。
		现在的情况是，所以场景都将场景对象添加到统一的一个渲染树中：
			第一，会导致非当前游戏的其他游戏场景，游戏对象没有资源，且切换游戏后也不一定就会正常加载
			第二，渲染树已开就添加了所有的游戏对象。并不符合设计要求和性能要求。
	怎么改：
		第一：改回原来的每个场景独自用于一个渲染树。切换游戏和场景就只是切换渲染树的显示。其他场景和游戏都占据内存。这是最早的方案。
		第二：将场景和场景对象分开。进入该场景时，再生成场景中的对象并加入节点，退出就统统释放清空节点。其他不变。但是其他非当前游戏和场景会占据内存。
		第三：场景和游戏都添加机制，即并不在游戏开始时就生成所有场景和游戏。而是当检测到进入某个游戏/场景，再释放上一个游戏/场景，并生成当前游戏/场景。
			这样改内存占用最小，也不需要单独去分割场景和场景对象的生成。但是释放和生成操作很多。不过游戏体量很小，即时玩家频繁切换也没有什么影响。
		打算按照方案三修改。
			要点注意：
				游戏和场景的exit要添加释放代码
				代码顺序应该是：游戏exit----场景exit（先释放堆数据，再释放独立节点，比如子弹池或者怪物池等）----渲染节点释放（节点管理器处理）----游戏资源释放（资源管理器处理）
				场景、游戏和对象的基类析构都应该是虚析构。
				应该手动调用下基类的exit。
	具体改动部分：
		游戏管理器：完成
			初始化，只生成默认第一个游戏
			游戏切换，删除上一个，生成下一个
		游戏基类：完成
			场景切换，删除上一个，生成下一个，不同游戏场景生成需求不同，初步三个方案：
				第一：基类中的函数虚函数化，由子类重写。根据不同游戏情况生成不同的场景。
				第二：基类中只写清空上一个场景的代码，子类重写时先调用基类的函数，在添加独自有的创建新场景的代码
				第三：基类中添加两个函数（清除当前场景和新增场景）。并在切换函数中顺序调用这两个函数。然后将这两个函数虚函数化，派生类可以根据自身需要重写。目前看一般只需要重写新增场景的函数即可。
			方案三好。好扩展，流程也可控。
		游戏派生类：完成
			增加生成函数重写，修改之前的创建场景的代码。
	明天计划：
		梳理各个游戏和场景的exit函数，确保做到资源释放。
			要点注意：
				游戏和场景的exit要添加释放代码，先看游戏，再看场景
				代码顺序应该是：游戏exit----场景exit（先释放堆数据，再释放独立节点，比如子弹池或者怪物池等）----渲染节点释放（节点管理器处理）----游戏资源释放（资源管理器处理）
				场景、游戏和对象的基类析构都应该是虚析构。
				应该手动调用下基类的exit。

2025-9-25：
	今日完成：
		优化了游戏类的exit逻辑
		完善了节点树的清空逻辑
		添加了节点类型概念，已经相关遍历判定代码。
		遍历代码添加了隐藏判定的判定。
	明日内容：
		scene类的还没写完，需要在场景基类的input、update和render等基础函数上加上对节点树的遍历和调用节点的相关代码。
		注意，scene和game的exit函数执行的实际是类型析构的功能。但是节点的exit函数是退场，退出渲染的功能。两边要分清楚。
	另外:
		关于怪物池和子弹池之类，打算改队列为单独的节点，有现成的代码可以复用。如同清空节点树一样也好清理。
		至于和AI讨论的双缓冲，感觉游戏体量还小，没这个必要。当然也可以加上。
2025-9-27：
	今日完成：
		将所有框架上的东西改完了。
	明日休息
	后天计划：
		调试游戏。同时检查框架上还有哪些要改。目前游戏运行有问题。
	今日报错总结：
		1、INIT_TYPE_NAME(ClassName) 宏放错位置
			该宏用于初始化类的静态成员 type_name，需在对应 .cpp 文件中定义（仅定义 1 次）。
			但是我放在.h文件后，导致所有包含该头文件的 .cpp 编译时都生成 1 份 type_name 定义，链接冲突。
		2、scene文件中，将on_init设置为纯虚函数后还在构造函数中调用，导致报错。
			纯虚函数无法被直接调用。只能调用派生类重写过后的。
		3、class Obj中，is_type函数的函数体有拼写错误，导致代码识别不了。
			低级错误。将type_name写错成type::name，居然一直没发现。
		4、game中用create_scene错误设置为静态函数，在函数体中访问了非静态成员scene_pool。
			记住，静态函数只能访问静态成员！！！！！
		5、用智能指针管理的类，其析构函数不得设置为私有。
			GameCollisionBox 的析构函数被声明为 private，导致智能指针在销毁对象时编译失败。
			智能指针管理对象时，要求对象的析构函数是 “可访问的”（通常是 public），否则无法完成自动销毁。
			
			
2025-9-29：
	今日完成：
		修改了开始游戏相关bug
		因为目前是执行按钮点即时击切换游戏的逻辑，游戏切换会直接删除当前游戏和生成新游戏，导致对象树正在遍历对象依次回调事件检测时，
		遍历对象全部被删，然后报错。
		解决办法就是在事件变量完成后再执行。
			一个是在场景中重写更新函数，并在按钮中添加可执行回调的状态，然后在更新函数中检测这个状态并执行回调。
			另一个就是之前说过的做一个事件系统。打算做这个。
	明日计划：
		添加事件系统到游戏中，争取明天之内全部搞定。
		思路：
			事件表：哈希+vector   哈希<字符串：事件类型， vector<{事件对象，回调函数}>>
			事件管理器：
				定义事件表
				定义事件结构
					事件类型			字符串
					事件对象			WS指针
					回调函数
					是否执行一次		int/bool 只执行一次的，执行后要删除。另外要考虑要不要限定执行次数
					是否可以重复注册	bool 不可重复注册的，注册前要遍历一遍是否已经注册过。
					是否可执行		bool
					是否可删除		bool
				注册事件：添加表内容。
					注意先判定是否重复注册
				注销时间：删除表中内容。
					结合重复注册，看是删一个还是全删
				发送事件：将表中匹配的事件表成员，标记为可执行
					思考同一个对象同一个事件出现不同回调函数的可能
					执行后要根据
				事件执行：在更新循环的开始或结束时，统一将所以可执行执行，并删除。
					删除前判定是否可删除。
				事件清理：
					将标记为可删除的删除
					将对象已经失效的删除
			回调参数传递：
				用键值对表统一传递参数：std::unordered_map<std::string, std::any> data
					这个就像获取服务器数据一样。两边约定好即可。只是很多地方需要做类型转换。
			事件对象：
				这个应该是回调函数的执行对象，不可或缺的。执行函数回调时必须先判断对象是否有效。

2025-9-30：
	今天写事件系统。突然想到我的节点如果要删除，也最好加上删除标记，然后统一在帧末尾回收。
	然后vector的遍历效率高于list非常多。除了删除效率低一些。
	list的优势主要是数据的插入和中间头部删除方面。在事件列表和渲染树中并不明显。
	今天先写事件。后面改一下节点的子节点列表。
	
	今日完成：
		完成了事件管理类的开发
	明日计划：
		将对象节点的子节点列表改为vector。以及修改相关功能函数。
	
2025-10-7
	关于事件管理，还需要思考一个问题，就是如何统一监听鼠标移动和点击事件。
	目前思路是统一在管理类中监听，然后发送相关的数据给监听的对象。只有注册了相关事件的对象才会收到鼠标的消息。
	
	子节点改vector等事件做完再说
	
2025-10-8
	今日完成：
		初步完成事件系统
	明日计划：
		子节点列表改list为vector，另外推动幸存者游戏完成
2025-10-9
	今日完成：
		子节点列表改list为vector
		添加碰撞事件类型，将碰撞回调通过事件系统调用
		幸存者游戏修改部分代码
	明日计划：
		继续推动幸存者游戏完成
	
2025-10-10
	我就是想要事件发生时，统一在主循环中执行事件。可是为啥越来越复杂了。
	检测键盘按钮又要新添加SDL的事件分发，新增相应的枚举
	越做越复杂了。
	我在想能否将我的事件系统如SDL一样。依旧使用之前的on_input函数。
	如果只是监听原有的SDL事件则代码不改。
	但是还能接收自定义事件。
	然后发现人家SDL本来就支持自定义事件的，我斯巴达了
	今天先写到这里。明天再改改改改改！
2025-10-14
	现在的问题是目前幸存者游戏出问题了。运行错误。
	主要是子弹旋转环绕上有些问题。
	今天打算将幸存者主角的环绕子弹单独做成一个控件box。
	之前是用一个vector表来管理，现在则直接将之作为box的子节点。然后box再作为角色的子节点。
	然后又考虑到和场景之间的互动，又在事件管理类中添加了临时事件注册，添加和修改部分代码。
2025-10-15
	目前是添加了三个子弹事件到枚举中。
	同时将子弹box从角色中独立出来，放在了游戏层。
	然后目前是游戏逻辑有问题。明天再看了。
		子弹自转未生效
		子弹和怪碰撞有问题
		其他...
2025-10-16
	完善碰撞逻辑
	场景基类更新添加do版本。避免子类重写的函数总要调用基类的函数。这个先改一个，明天验证后再看要不要推广。
	特别是涉及到场景节点对象的。
	
2025-10-22
	碰撞标的的认定，不能用指针，应该用ID
	但是目前游戏中的ID，本质是name。当前命名name时多是随手写，多为重复的。如果要求全局唯一，必须单开一个字段逻辑。
	
	明天单独写个ID逻辑。然后看要不要将之前的ID相关字段改为name。做到名副其实。
	